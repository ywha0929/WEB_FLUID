{"ast":null,"code":"'use strict';\n\nimport { NativeModules } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nconst Sockets = NativeModules.TcpSockets;\nimport Socket from './Socket';\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {object} ServerEvents\n * @property {() => void} close\n * @property {(socket: Socket) => void} connection\n * @property {() => void} listening\n * @property {(err: Error) => void} error\n *\n * @extends {EventEmitter<ServerEvents, any>}\n */\nexport default class Server extends EventEmitter {\n  /**\n   * @param {(socket: Socket) => void} [connectionCallback] Automatically set as a listener for the `'connection'` event.\n   */\n  constructor(connectionCallback) {\n    super();\n    /** @private */\n    this._id = getNextId();\n    /** @private */\n    this._eventEmitter = nativeEventEmitter;\n    /** @private @type {Set<Socket>} */\n    this._connections = new Set();\n    /** @private */\n    this._localAddress = undefined;\n    /** @private */\n    this._localPort = undefined;\n    /** @private */\n    this._localFamily = undefined;\n    this.listening = false;\n    this._registerEvents();\n    if (connectionCallback) this.on('connection', connectionCallback);\n    this.on('close', this._setDisconnected, this);\n  }\n\n  /**\n   * Start a server listening for connections.\n   *\n   * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted.\n   * The last parameter `callback` will be added as a listener for the `'listening'` event.\n   *\n   * The `server.listen()` method can be called again if and only if there was an error during the first\n   * `server.listen()` call or `server.close()` has been called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN`\n   * error will be thrown.\n   *\n   * @param {{ port: number; host: string; reuseAddress?: boolean}} options\n   * @param {() => void} [callback]\n   * @returns {Server}\n   */\n  listen(options, callback) {\n    if (this._localAddress !== undefined) throw new Error('ERR_SERVER_ALREADY_LISTEN');\n    const gotOptions = {\n      ...options\n    };\n    gotOptions.host = gotOptions.host || '0.0.0.0';\n    this.once('listening', () => {\n      this.listening = true;\n      if (callback) callback();\n    });\n    Sockets.listen(this._id, gotOptions);\n    return this;\n  }\n\n  /**\n   * Asynchronously get the number of concurrent connections on the server.\n   *\n   * Callback should take two arguments `err` and `count`.\n   *\n   * @param {(err: Error | null, count: number) => void} callback\n   * @returns {Server}\n   */\n  getConnections(callback) {\n    callback(null, this._connections.size);\n    return this;\n  }\n\n  /**\n   * Stops the server from accepting new connections and keeps existing connections.\n   * This function is asynchronous, the server is finally closed when all connections are ended and the server emits a `'close'` event.\n   * The optional callback will be called once the `'close'` event occurs. Unlike that event, it will be called with an `Error` as its\n   * only argument if the server was not open when it was closed.\n   *\n   * @param {(err?: Error) => void} [callback] Called when the server is closed.\n   * @returns {Server}\n   */\n  close(callback) {\n    if (!this._localAddress) {\n      callback === null || callback === void 0 ? void 0 : callback(new Error('ERR_SERVER_NOT_RUNNING'));\n      return this;\n    }\n    if (callback) this.once('close', callback);\n    this.listening = false;\n    Sockets.close(this._id);\n    return this;\n  }\n\n  /**\n   * Returns the bound `address`, the address `family` name, and `port` of the server as reported by the operating system if listening\n   * on an IP socket (useful to find which port was assigned when getting an OS-assigned address):\n   * `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n   *\n   * @returns {import('./Socket').AddressInfo | null}\n   */\n  address() {\n    if (!this._localAddress) return null;\n    return {\n      address: this._localAddress,\n      port: this._localPort,\n      family: this._localFamily\n    };\n  }\n  ref() {\n    console.warn('react-native-tcp-socket: Server.ref() method will have no effect.');\n    return this;\n  }\n  unref() {\n    console.warn('react-native-tcp-socket: Server.unref() method will have no effect.');\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _registerEvents() {\n    this._errorListener = this._eventEmitter.addListener('listening', evt => {\n      if (evt.id !== this._id) return;\n      this._localAddress = evt.connection.localAddress;\n      this._localPort = evt.connection.localPort;\n      this._localFamily = evt.connection.localFamily;\n      this.emit('listening');\n    });\n    this._errorListener = this._eventEmitter.addListener('error', evt => {\n      if (evt.id !== this._id) return;\n      this.close();\n      this.emit('error', evt.error);\n    });\n    this._connectionsListener = this._eventEmitter.addListener('connection', evt => {\n      if (evt.id !== this._id) return;\n      const newSocket = this._buildSocket(evt.info);\n      // Emit 'close' when all connection closed\n      newSocket.on('close', () => {\n        this._connections.delete(newSocket);\n        if (!this.listening && this._connections.size === 0) this.emit('close');\n      });\n      this._connections.add(newSocket);\n      this.emit('connection', newSocket);\n    });\n  }\n\n  /**\n   * @private\n   */\n  _setDisconnected() {\n    this._localAddress = undefined;\n    this._localPort = undefined;\n    this._localFamily = undefined;\n  }\n\n  /**\n   * @private\n   * @param {{ id: number; connection: import('./Socket').NativeConnectionInfo; }} info\n   * @returns {Socket}\n   */\n  _buildSocket(info) {\n    const newSocket = new Socket();\n    newSocket._setId(info.id);\n    newSocket._setConnected(info.connection);\n    return newSocket;\n  }\n}","map":{"version":3,"names":["NativeModules","EventEmitter","Sockets","TcpSockets","Socket","nativeEventEmitter","getNextId","Server","constructor","connectionCallback","_id","_eventEmitter","_connections","Set","_localAddress","undefined","_localPort","_localFamily","listening","_registerEvents","on","_setDisconnected","listen","options","callback","Error","gotOptions","host","once","getConnections","size","close","address","port","family","ref","console","warn","unref","_errorListener","addListener","evt","id","connection","localAddress","localPort","localFamily","emit","error","_connectionsListener","newSocket","_buildSocket","info","delete","add","_setId","_setConnected"],"sources":["/home/ywha/WEB_FLUID/react_proxy/src/node_modules/react-native-tcp-socket/src/Server.js"],"sourcesContent":["'use strict';\n\nimport { NativeModules } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nconst Sockets = NativeModules.TcpSockets;\nimport Socket from './Socket';\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {object} ServerEvents\n * @property {() => void} close\n * @property {(socket: Socket) => void} connection\n * @property {() => void} listening\n * @property {(err: Error) => void} error\n *\n * @extends {EventEmitter<ServerEvents, any>}\n */\nexport default class Server extends EventEmitter {\n    /**\n     * @param {(socket: Socket) => void} [connectionCallback] Automatically set as a listener for the `'connection'` event.\n     */\n    constructor(connectionCallback) {\n        super();\n        /** @private */\n        this._id = getNextId();\n        /** @private */\n        this._eventEmitter = nativeEventEmitter;\n        /** @private @type {Set<Socket>} */\n        this._connections = new Set();\n        /** @private */\n        this._localAddress = undefined;\n        /** @private */\n        this._localPort = undefined;\n        /** @private */\n        this._localFamily = undefined;\n        this.listening = false;\n        this._registerEvents();\n        if (connectionCallback) this.on('connection', connectionCallback);\n        this.on('close', this._setDisconnected, this);\n    }\n\n    /**\n     * Start a server listening for connections.\n     *\n     * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted.\n     * The last parameter `callback` will be added as a listener for the `'listening'` event.\n     *\n     * The `server.listen()` method can be called again if and only if there was an error during the first\n     * `server.listen()` call or `server.close()` has been called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN`\n     * error will be thrown.\n     *\n     * @param {{ port: number; host: string; reuseAddress?: boolean}} options\n     * @param {() => void} [callback]\n     * @returns {Server}\n     */\n    listen(options, callback) {\n        if (this._localAddress !== undefined) throw new Error('ERR_SERVER_ALREADY_LISTEN');\n        const gotOptions = { ...options };\n        gotOptions.host = gotOptions.host || '0.0.0.0';\n        this.once('listening', () => {\n            this.listening = true;\n            if (callback) callback();\n        });\n        Sockets.listen(this._id, gotOptions);\n        return this;\n    }\n\n    /**\n     * Asynchronously get the number of concurrent connections on the server.\n     *\n     * Callback should take two arguments `err` and `count`.\n     *\n     * @param {(err: Error | null, count: number) => void} callback\n     * @returns {Server}\n     */\n    getConnections(callback) {\n        callback(null, this._connections.size);\n        return this;\n    }\n\n    /**\n     * Stops the server from accepting new connections and keeps existing connections.\n     * This function is asynchronous, the server is finally closed when all connections are ended and the server emits a `'close'` event.\n     * The optional callback will be called once the `'close'` event occurs. Unlike that event, it will be called with an `Error` as its\n     * only argument if the server was not open when it was closed.\n     *\n     * @param {(err?: Error) => void} [callback] Called when the server is closed.\n     * @returns {Server}\n     */\n    close(callback) {\n        if (!this._localAddress) {\n            callback?.(new Error('ERR_SERVER_NOT_RUNNING'));\n            return this;\n        }\n        if (callback) this.once('close', callback);\n        this.listening = false;\n        Sockets.close(this._id);\n        return this;\n    }\n\n    /**\n     * Returns the bound `address`, the address `family` name, and `port` of the server as reported by the operating system if listening\n     * on an IP socket (useful to find which port was assigned when getting an OS-assigned address):\n     * `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n     *\n     * @returns {import('./Socket').AddressInfo | null}\n     */\n    address() {\n        if (!this._localAddress) return null;\n        return { address: this._localAddress, port: this._localPort, family: this._localFamily };\n    }\n\n    ref() {\n        console.warn('react-native-tcp-socket: Server.ref() method will have no effect.');\n        return this;\n    }\n\n    unref() {\n        console.warn('react-native-tcp-socket: Server.unref() method will have no effect.');\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    _registerEvents() {\n        this._errorListener = this._eventEmitter.addListener('listening', (evt) => {\n            if (evt.id !== this._id) return;\n            this._localAddress = evt.connection.localAddress;\n            this._localPort = evt.connection.localPort;\n            this._localFamily = evt.connection.localFamily;\n            this.emit('listening');\n        });\n        this._errorListener = this._eventEmitter.addListener('error', (evt) => {\n            if (evt.id !== this._id) return;\n            this.close();\n            this.emit('error', evt.error);\n        });\n        this._connectionsListener = this._eventEmitter.addListener('connection', (evt) => {\n            if (evt.id !== this._id) return;\n            const newSocket = this._buildSocket(evt.info);\n            // Emit 'close' when all connection closed\n            newSocket.on('close', () => {\n                this._connections.delete(newSocket);\n                if (!this.listening && this._connections.size === 0) this.emit('close');\n            });\n            this._connections.add(newSocket);\n            this.emit('connection', newSocket);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _setDisconnected() {\n        this._localAddress = undefined;\n        this._localPort = undefined;\n        this._localFamily = undefined;\n    }\n\n    /**\n     * @private\n     * @param {{ id: number; connection: import('./Socket').NativeConnectionInfo; }} info\n     * @returns {Socket}\n     */\n    _buildSocket(info) {\n        const newSocket = new Socket();\n        newSocket._setId(info.id);\n        newSocket._setConnected(info.connection);\n        return newSocket;\n    }\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,SAASA,aAAa,QAAQ,cAAc;AAC5C,OAAOC,YAAY,MAAM,eAAe;AACxC,MAAMC,OAAO,GAAGF,aAAa,CAACG,UAAU;AACxC,OAAOC,MAAM,MAAM,UAAU;AAC7B,SAASC,kBAAkB,EAAEC,SAAS,QAAQ,WAAW;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,MAAM,SAASN,YAAY,CAAC;EAC7C;AACJ;AACA;EACIO,WAAWA,CAACC,kBAAkB,EAAE;IAC5B,KAAK,EAAE;IACP;IACA,IAAI,CAACC,GAAG,GAAGJ,SAAS,EAAE;IACtB;IACA,IAAI,CAACK,aAAa,GAAGN,kBAAkB;IACvC;IACA,IAAI,CAACO,YAAY,GAAG,IAAIC,GAAG,EAAE;IAC7B;IACA,IAAI,CAACC,aAAa,GAAGC,SAAS;IAC9B;IACA,IAAI,CAACC,UAAU,GAAGD,SAAS;IAC3B;IACA,IAAI,CAACE,YAAY,GAAGF,SAAS;IAC7B,IAAI,CAACG,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,eAAe,EAAE;IACtB,IAAIV,kBAAkB,EAAE,IAAI,CAACW,EAAE,CAAC,YAAY,EAAEX,kBAAkB,CAAC;IACjE,IAAI,CAACW,EAAE,CAAC,OAAO,EAAE,IAAI,CAACC,gBAAgB,EAAE,IAAI,CAAC;EACjD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACC,OAAO,EAAEC,QAAQ,EAAE;IACtB,IAAI,IAAI,CAACV,aAAa,KAAKC,SAAS,EAAE,MAAM,IAAIU,KAAK,CAAC,2BAA2B,CAAC;IAClF,MAAMC,UAAU,GAAG;MAAE,GAAGH;IAAQ,CAAC;IACjCG,UAAU,CAACC,IAAI,GAAGD,UAAU,CAACC,IAAI,IAAI,SAAS;IAC9C,IAAI,CAACC,IAAI,CAAC,WAAW,EAAE,MAAM;MACzB,IAAI,CAACV,SAAS,GAAG,IAAI;MACrB,IAAIM,QAAQ,EAAEA,QAAQ,EAAE;IAC5B,CAAC,CAAC;IACFtB,OAAO,CAACoB,MAAM,CAAC,IAAI,CAACZ,GAAG,EAAEgB,UAAU,CAAC;IACpC,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,cAAcA,CAACL,QAAQ,EAAE;IACrBA,QAAQ,CAAC,IAAI,EAAE,IAAI,CAACZ,YAAY,CAACkB,IAAI,CAAC;IACtC,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,KAAKA,CAACP,QAAQ,EAAE;IACZ,IAAI,CAAC,IAAI,CAACV,aAAa,EAAE;MACrBU,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG,IAAIC,KAAK,CAAC,wBAAwB,CAAC,CAAC;MAC/C,OAAO,IAAI;IACf;IACA,IAAID,QAAQ,EAAE,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEJ,QAAQ,CAAC;IAC1C,IAAI,CAACN,SAAS,GAAG,KAAK;IACtBhB,OAAO,CAAC6B,KAAK,CAAC,IAAI,CAACrB,GAAG,CAAC;IACvB,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIsB,OAAOA,CAAA,EAAG;IACN,IAAI,CAAC,IAAI,CAAClB,aAAa,EAAE,OAAO,IAAI;IACpC,OAAO;MAAEkB,OAAO,EAAE,IAAI,CAAClB,aAAa;MAAEmB,IAAI,EAAE,IAAI,CAACjB,UAAU;MAAEkB,MAAM,EAAE,IAAI,CAACjB;IAAa,CAAC;EAC5F;EAEAkB,GAAGA,CAAA,EAAG;IACFC,OAAO,CAACC,IAAI,CAAC,mEAAmE,CAAC;IACjF,OAAO,IAAI;EACf;EAEAC,KAAKA,CAAA,EAAG;IACJF,OAAO,CAACC,IAAI,CAAC,qEAAqE,CAAC;IACnF,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;EACIlB,eAAeA,CAAA,EAAG;IACd,IAAI,CAACoB,cAAc,GAAG,IAAI,CAAC5B,aAAa,CAAC6B,WAAW,CAAC,WAAW,EAAGC,GAAG,IAAK;MACvE,IAAIA,GAAG,CAACC,EAAE,KAAK,IAAI,CAAChC,GAAG,EAAE;MACzB,IAAI,CAACI,aAAa,GAAG2B,GAAG,CAACE,UAAU,CAACC,YAAY;MAChD,IAAI,CAAC5B,UAAU,GAAGyB,GAAG,CAACE,UAAU,CAACE,SAAS;MAC1C,IAAI,CAAC5B,YAAY,GAAGwB,GAAG,CAACE,UAAU,CAACG,WAAW;MAC9C,IAAI,CAACC,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC,CAAC;IACF,IAAI,CAACR,cAAc,GAAG,IAAI,CAAC5B,aAAa,CAAC6B,WAAW,CAAC,OAAO,EAAGC,GAAG,IAAK;MACnE,IAAIA,GAAG,CAACC,EAAE,KAAK,IAAI,CAAChC,GAAG,EAAE;MACzB,IAAI,CAACqB,KAAK,EAAE;MACZ,IAAI,CAACgB,IAAI,CAAC,OAAO,EAAEN,GAAG,CAACO,KAAK,CAAC;IACjC,CAAC,CAAC;IACF,IAAI,CAACC,oBAAoB,GAAG,IAAI,CAACtC,aAAa,CAAC6B,WAAW,CAAC,YAAY,EAAGC,GAAG,IAAK;MAC9E,IAAIA,GAAG,CAACC,EAAE,KAAK,IAAI,CAAChC,GAAG,EAAE;MACzB,MAAMwC,SAAS,GAAG,IAAI,CAACC,YAAY,CAACV,GAAG,CAACW,IAAI,CAAC;MAC7C;MACAF,SAAS,CAAC9B,EAAE,CAAC,OAAO,EAAE,MAAM;QACxB,IAAI,CAACR,YAAY,CAACyC,MAAM,CAACH,SAAS,CAAC;QACnC,IAAI,CAAC,IAAI,CAAChC,SAAS,IAAI,IAAI,CAACN,YAAY,CAACkB,IAAI,KAAK,CAAC,EAAE,IAAI,CAACiB,IAAI,CAAC,OAAO,CAAC;MAC3E,CAAC,CAAC;MACF,IAAI,CAACnC,YAAY,CAAC0C,GAAG,CAACJ,SAAS,CAAC;MAChC,IAAI,CAACH,IAAI,CAAC,YAAY,EAAEG,SAAS,CAAC;IACtC,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;EACI7B,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAACP,aAAa,GAAGC,SAAS;IAC9B,IAAI,CAACC,UAAU,GAAGD,SAAS;IAC3B,IAAI,CAACE,YAAY,GAAGF,SAAS;EACjC;;EAEA;AACJ;AACA;AACA;AACA;EACIoC,YAAYA,CAACC,IAAI,EAAE;IACf,MAAMF,SAAS,GAAG,IAAI9C,MAAM,EAAE;IAC9B8C,SAAS,CAACK,MAAM,CAACH,IAAI,CAACV,EAAE,CAAC;IACzBQ,SAAS,CAACM,aAAa,CAACJ,IAAI,CAACT,UAAU,CAAC;IACxC,OAAOO,SAAS;EACpB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}