{"ast":null,"code":"'use strict';\n\nimport { NativeModules, Image } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nconst Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {\"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\"} BufferEncoding\n *\n * @typedef {import('react-native').NativeEventEmitter} NativeEventEmitter\n *\n * @typedef {{address: string, family: string, port: number}} AddressInfo\n *\n * @typedef {{localAddress: string, localPort: number, remoteAddress: string, remotePort: number, remoteFamily: string}} NativeConnectionInfo\n *\n * @typedef {{\n * port: number;\n * host?: string;\n * timeout?: number,\n * localAddress?: string,\n * localPort?: number,\n * interface?: 'wifi' | 'cellular' | 'ethernet',\n * reuseAddress?: boolean,\n * tls?: boolean,\n * tlsCheckValidity?: boolean,\n * tlsCert?: any,\n * }} ConnectionOptions\n *\n * @typedef {object} ReadableEvents\n * @property {() => void} pause\n * @property {() => void} resume\n *\n * @typedef {object} SocketEvents\n * @property {(had_error: boolean) => void} close\n * @property {() => void} connect\n * @property {(data: Buffer | string) => void} data\n * @property {() => void} drain\n * @property {(err: Error) => void} error\n * @property {() => void} timeout\n *\n * @extends {EventEmitter<SocketEvents & ReadableEvents, any>}\n */\nexport default class Socket extends EventEmitter {\n  /**\n   * Creates a new socket object.\n   */\n  constructor() {\n    super();\n    /** @private */\n    /**\n     * @private\n     */\n    this._onDeviceDataEvt = ( /** @type {{ id: number; data: string; }} */evt) => {\n      if (evt.id !== this._id) return;\n      if (!this._paused) {\n        const bufferData = Buffer.from(evt.data, 'base64');\n        this._bytesRead += bufferData.byteLength;\n        const finalData = this._encoding ? bufferData.toString(this._encoding) : bufferData;\n        this.emit('data', finalData);\n      } else {\n        // If the socket is paused, save the data events for later\n        this._pausedDataEvents.push(evt);\n      }\n    };\n    this._id = undefined;\n    /** @private */\n    this._eventEmitter = nativeEventEmitter;\n    /** @type {EventEmitter<'written', any>} @private */\n    this._msgEvtEmitter = new EventEmitter();\n    /** @type {number} @private */\n    this._timeoutMsecs = 0;\n    /** @type {number | undefined} @private */\n    this._timeout = undefined;\n    /** @private */\n    this._encoding = undefined;\n    /** @private */\n    this._msgId = 0;\n    /** @private */\n    this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n    /** @private */\n    this._lastSentMsgId = 0;\n    /** @private */\n    this._paused = false;\n    /** @private */\n    this._resuming = false;\n    /** @private */\n    this._writeBufferSize = 0;\n    /** @private */\n    this._bytesRead = 0;\n    /** @private */\n    this._bytesWritten = 0;\n    /** @private */\n    this._connecting = false;\n    /** @private */\n    this._pending = true;\n    /** @private */\n    this._destroyed = false;\n    // TODO: Add readOnly and writeOnly states\n    /** @type {'opening' | 'open' | 'readOnly' | 'writeOnly'} @private */\n    this._readyState = 'open'; // Incorrect, but matches NodeJS behavior\n    /** @type {{ id: number; data: string; }[]} @private */\n    this._pausedDataEvents = [];\n    this.readableHighWaterMark = 16384;\n    this.writableHighWaterMark = 16384;\n    this.writableNeedDrain = false;\n    this.localAddress = undefined;\n    this.localPort = undefined;\n    this.remoteAddress = undefined;\n    this.remotePort = undefined;\n    this.remoteFamily = undefined;\n    this._registerEvents();\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  get pending() {\n    return this._pending;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get bytesWritten() {\n    return this._bytesWritten;\n  }\n  get bytesRead() {\n    return this._bytesRead;\n  }\n  get timeout() {\n    return this._timeout;\n  }\n\n  /**\n   * @package\n   * @param {number} id\n   */\n  _setId(id) {\n    this._id = id;\n    this._registerEvents();\n  }\n\n  /**\n   * @package\n   * @param {NativeConnectionInfo} connectionInfo\n   */\n  _setConnected(connectionInfo) {\n    this._connecting = false;\n    this._readyState = 'open';\n    this._pending = false;\n    this.localAddress = connectionInfo.localAddress;\n    this.localPort = connectionInfo.localPort;\n    this.remoteAddress = connectionInfo.remoteAddress;\n    this.remoteFamily = connectionInfo.remoteFamily;\n    this.remotePort = connectionInfo.remotePort;\n  }\n\n  /**\n   * @param {ConnectionOptions} options\n   * @param {() => void} [callback]\n   */\n  connect(options, callback) {\n    if (this._id === undefined) this._setId(getNextId());\n    const customOptions = {\n      ...options\n    };\n    // Normalize args\n    customOptions.host = customOptions.host || 'localhost';\n    customOptions.port = Number(customOptions.port) || 0;\n    this.once('connect', () => {\n      if (callback) callback();\n    });\n    // Timeout\n    if (customOptions.timeout) this.setTimeout(customOptions.timeout);else if (this._timeout) this._activateTimer();\n    // TLS Cert\n    if (customOptions.tlsCert) {\n      customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n    }\n    this._connecting = true;\n    this._readyState = 'opening';\n    Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n    return this;\n  }\n\n  /**\n   * Sets the socket to timeout after `timeout` milliseconds of inactivity on the socket. By default `TcpSocket` do not have a timeout.\n   *\n   * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed.\n   * The user must manually call `socket.end()` or `socket.destroy()` to end the connection.\n   *\n   * If `timeout` is 0, then the existing idle timeout is disabled.\n   *\n   * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n   *\n   * @param {number} timeout\n   * @param {() => void} [callback]\n   */\n  setTimeout(timeout, callback) {\n    if (timeout === 0) {\n      this._clearTimeout();\n    } else {\n      this._activateTimer(timeout);\n    }\n    if (callback) this.once('timeout', callback);\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {number} [timeout]\n   */\n  _activateTimer(timeout) {\n    if (timeout !== undefined) this._timeoutMsecs = timeout;\n    this._clearTimeout();\n    this._timeout = setTimeout(() => {\n      this._clearTimeout();\n      this.emit('timeout');\n    }, this._timeoutMsecs);\n  }\n\n  /**\n   * @private\n   */\n  _clearTimeout() {\n    if (this._timeout !== undefined) {\n      clearTimeout(this._timeout);\n      this._timeout = undefined;\n    }\n  }\n\n  /**\n   * Set the encoding for the socket as a Readable Stream. By default, no encoding is assigned and stream data will be returned as `Buffer` objects.\n   * Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as Buffer objects.\n   *\n   * For instance, calling `socket.setEncoding('utf8')` will cause the output data to be interpreted as UTF-8 data, and passed as strings.\n   * Calling `socket.setEncoding('hex')` will cause the data to be encoded in hexadecimal string format.\n   *\n   * @param {BufferEncoding} [encoding]\n   */\n  setEncoding(encoding) {\n    this._encoding = encoding;\n    return this;\n  }\n\n  /**\n   * Enable/disable the use of Nagle's algorithm. When a TCP connection is created, it will have Nagle's algorithm enabled.\n   *\n   * Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.\n   *\n   * Passing `true` for `noDelay` or not passing an argument will disable Nagle's algorithm for the socket. Passing false for noDelay will enable Nagle's algorithm.\n   *\n   * @param {boolean} noDelay Default: `true`\n   */\n  setNoDelay() {\n    let noDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (this._pending) {\n      this.once('connect', () => this.setNoDelay(noDelay));\n      return this;\n    }\n    Sockets.setNoDelay(this._id, noDelay);\n    return this;\n  }\n\n  /**\n   * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n   *\n   * `initialDelay` is ignored.\n   *\n   * @param {boolean} enable Default: `false`\n   * @param {number} initialDelay ***IGNORED**. Default: `0`\n   */\n  setKeepAlive() {\n    let enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let initialDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this._pending) {\n      this.once('connect', () => this.setKeepAlive(enable, initialDelay));\n      return this;\n    }\n    if (initialDelay !== 0) {\n      console.warn('react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored');\n    }\n    Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n    return this;\n  }\n\n  /**\n   * Returns the bound `address`, the address `family` name and `port` of the socket as reported\n   * by the operating system: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n   *\n   * @returns {AddressInfo | {}}\n   */\n  address() {\n    if (!this.localAddress) return {};\n    return {\n      address: this.localAddress,\n      family: this.remoteFamily,\n      port: this.localPort\n    };\n  }\n\n  /**\n   * Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.\n   *\n   * @param {string | Buffer | Uint8Array} [data]\n   * @param {BufferEncoding} [encoding]\n   */\n  end(data, encoding) {\n    if (data) {\n      this.write(data, encoding, () => {\n        Sockets.end(this._id);\n      });\n      return this;\n    }\n    if (this._pending || this._destroyed) return this;\n    this._clearTimeout();\n    Sockets.end(this._id);\n    return this;\n  }\n\n  /**\n   * Ensures that no more I/O activity happens on this socket. Destroys the stream and closes the connection.\n   */\n  destroy() {\n    if (this._pending || this._destroyed) return this;\n    this._destroyed = true;\n    this._clearTimeout();\n    Sockets.destroy(this._id);\n    return this;\n  }\n\n  /**\n   * Sends data on the socket. The second parameter specifies the encoding in the case of a string — it defaults to UTF8 encoding.\n   *\n   * Returns `true` if the entire data was flushed successfully to the kernel buffer. Returns `false` if all or part of the data\n   * was queued in user memory. `'drain'` will be emitted when the buffer is again free.\n   *\n   * The optional callback parameter will be executed when the data is finally written out, which may not be immediately.\n   *\n   * @param {string | Buffer | Uint8Array} buffer\n   * @param {BufferEncoding} [encoding]\n   * @param {(err?: Error) => void} [cb]\n   *\n   * @return {boolean}\n   */\n  write(buffer, encoding, cb) {\n    const self = this;\n    if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n    const generatedBuffer = this._generateSendBuffer(buffer, encoding);\n    this._writeBufferSize += generatedBuffer.byteLength;\n    const currentMsgId = this._msgId;\n    this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n    const msgEvtHandler = ( /** @type {{id: number, msgId: number, err?: string}} */evt) => {\n      const {\n        msgId,\n        err\n      } = evt;\n      if (msgId === currentMsgId) {\n        this._msgEvtEmitter.removeListener('written', msgEvtHandler);\n        this._writeBufferSize -= generatedBuffer.byteLength;\n        this._lastRcvMsgId = msgId;\n        if (self._timeout) self._activateTimer();\n        if (this.writableNeedDrain && this._lastSentMsgId === msgId) {\n          this.writableNeedDrain = false;\n          this.emit('drain');\n        }\n        if (cb) {\n          if (err) cb(new Error(err));else cb();\n        }\n      }\n    };\n    // Callback equivalent with better performance\n    this._msgEvtEmitter.on('written', msgEvtHandler, this);\n    const ok = this._writeBufferSize < this.writableHighWaterMark;\n    if (!ok) this.writableNeedDrain = true;\n    this._lastSentMsgId = currentMsgId;\n    this._bytesWritten += generatedBuffer.byteLength;\n    Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n    return ok;\n  }\n\n  /**\n   * Pauses the reading of data. That is, `'data'` events will not be emitted. Useful to throttle back an upload.\n   */\n  pause() {\n    if (this._paused) return;\n    this._paused = true;\n    Sockets.pause(this._id);\n    this.emit('pause');\n  }\n\n  /**\n   * Resumes reading after a call to `socket.pause()`.\n   */\n  resume() {\n    if (!this._paused) return;\n    this._paused = false;\n    this.emit('resume');\n    this._recoverDataEventsAfterPause();\n  }\n  ref() {\n    console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n  }\n  unref() {\n    console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n  }\n\n  /**\n   * @private\n   */\n  async _recoverDataEventsAfterPause() {\n    if (this._resuming) return;\n    this._resuming = true;\n    while (this._pausedDataEvents.length > 0) {\n      // Concat all buffered events for better performance\n      const buffArray = [];\n      let readBytes = 0;\n      let i = 0;\n      for (; i < this._pausedDataEvents.length; i++) {\n        const evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n        readBytes += evtData.byteLength;\n        if (readBytes <= this.readableHighWaterMark) {\n          buffArray.push(evtData);\n        } else {\n          const buffOffset = this.readableHighWaterMark - readBytes;\n          buffArray.push(evtData.slice(0, buffOffset));\n          this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n          break;\n        }\n      }\n      // Generate new event with the concatenated events\n      const evt = {\n        id: this._pausedDataEvents[0].id,\n        data: Buffer.concat(buffArray).toString('base64')\n      };\n      // Clean the old events\n      this._pausedDataEvents = this._pausedDataEvents.slice(i);\n      this._onDeviceDataEvt(evt);\n      if (this._paused) {\n        this._resuming = false;\n        return;\n      }\n    }\n    this._resuming = false;\n    Sockets.resume(this._id);\n  }\n  /**\n   * @private\n   */\n  _registerEvents() {\n    this._unregisterEvents();\n    this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n    this._errorListener = this._eventEmitter.addListener('error', evt => {\n      if (evt.id !== this._id) return;\n      this.destroy();\n      this.emit('error', evt.error);\n    });\n    this._closeListener = this._eventEmitter.addListener('close', evt => {\n      if (evt.id !== this._id) return;\n      this._setDisconnected();\n      this.emit('close', evt.error);\n    });\n    this._connectListener = this._eventEmitter.addListener('connect', evt => {\n      if (evt.id !== this._id) return;\n      this._setConnected(evt.connection);\n      this.emit('connect');\n    });\n    this._writtenListener = this._eventEmitter.addListener('written', evt => {\n      if (evt.id !== this._id) return;\n      this._msgEvtEmitter.emit('written', evt);\n    });\n  }\n\n  /**\n   * @private\n   */\n  _unregisterEvents() {\n    var _this$_dataListener, _this$_errorListener, _this$_closeListener, _this$_connectListene, _this$_writtenListene;\n    (_this$_dataListener = this._dataListener) === null || _this$_dataListener === void 0 ? void 0 : _this$_dataListener.remove();\n    (_this$_errorListener = this._errorListener) === null || _this$_errorListener === void 0 ? void 0 : _this$_errorListener.remove();\n    (_this$_closeListener = this._closeListener) === null || _this$_closeListener === void 0 ? void 0 : _this$_closeListener.remove();\n    (_this$_connectListene = this._connectListener) === null || _this$_connectListene === void 0 ? void 0 : _this$_connectListene.remove();\n    (_this$_writtenListene = this._writtenListener) === null || _this$_writtenListene === void 0 ? void 0 : _this$_writtenListene.remove();\n  }\n\n  /**\n   * @private\n   * @param {string | Buffer | Uint8Array} buffer\n   * @param {BufferEncoding} [encoding]\n   */\n  _generateSendBuffer(buffer, encoding) {\n    if (typeof buffer === 'string') {\n      return Buffer.from(buffer, encoding);\n    } else if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n      return Buffer.from(buffer);\n    } else {\n      throw new TypeError(`Invalid data, chunk must be a string or buffer, not ${typeof buffer}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _setDisconnected() {\n    this._unregisterEvents();\n  }\n}","map":{"version":3,"names":["NativeModules","Image","EventEmitter","Buffer","Sockets","TcpSockets","nativeEventEmitter","getNextId","Socket","constructor","_onDeviceDataEvt","evt","id","_id","_paused","bufferData","from","data","_bytesRead","byteLength","finalData","_encoding","toString","emit","_pausedDataEvents","push","undefined","_eventEmitter","_msgEvtEmitter","_timeoutMsecs","_timeout","_msgId","_lastRcvMsgId","Number","MAX_SAFE_INTEGER","_lastSentMsgId","_resuming","_writeBufferSize","_bytesWritten","_connecting","_pending","_destroyed","_readyState","readableHighWaterMark","writableHighWaterMark","writableNeedDrain","localAddress","localPort","remoteAddress","remotePort","remoteFamily","_registerEvents","readyState","destroyed","pending","connecting","bytesWritten","bytesRead","timeout","_setId","_setConnected","connectionInfo","connect","options","callback","customOptions","host","port","once","setTimeout","_activateTimer","tlsCert","resolveAssetSource","uri","_clearTimeout","clearTimeout","setEncoding","encoding","setNoDelay","noDelay","arguments","length","setKeepAlive","enable","initialDelay","console","warn","Math","floor","address","family","end","write","destroy","buffer","cb","self","Error","generatedBuffer","_generateSendBuffer","currentMsgId","msgEvtHandler","msgId","err","removeListener","on","ok","pause","resume","_recoverDataEventsAfterPause","ref","unref","buffArray","readBytes","i","evtData","buffOffset","slice","concat","_unregisterEvents","_dataListener","addListener","_errorListener","error","_closeListener","_setDisconnected","_connectListener","connection","_writtenListener","_this$_dataListener","_this$_errorListener","_this$_closeListener","_this$_connectListene","_this$_writtenListene","remove","isBuffer","Uint8Array","Array","isArray","TypeError"],"sources":["/home/ywha/WEB_FLUID/react_proxy/src/node_modules/react-native-tcp-socket/src/Socket.js"],"sourcesContent":["'use strict';\n\nimport { NativeModules, Image } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nconst Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {\"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\"} BufferEncoding\n *\n * @typedef {import('react-native').NativeEventEmitter} NativeEventEmitter\n *\n * @typedef {{address: string, family: string, port: number}} AddressInfo\n *\n * @typedef {{localAddress: string, localPort: number, remoteAddress: string, remotePort: number, remoteFamily: string}} NativeConnectionInfo\n *\n * @typedef {{\n * port: number;\n * host?: string;\n * timeout?: number,\n * localAddress?: string,\n * localPort?: number,\n * interface?: 'wifi' | 'cellular' | 'ethernet',\n * reuseAddress?: boolean,\n * tls?: boolean,\n * tlsCheckValidity?: boolean,\n * tlsCert?: any,\n * }} ConnectionOptions\n *\n * @typedef {object} ReadableEvents\n * @property {() => void} pause\n * @property {() => void} resume\n *\n * @typedef {object} SocketEvents\n * @property {(had_error: boolean) => void} close\n * @property {() => void} connect\n * @property {(data: Buffer | string) => void} data\n * @property {() => void} drain\n * @property {(err: Error) => void} error\n * @property {() => void} timeout\n *\n * @extends {EventEmitter<SocketEvents & ReadableEvents, any>}\n */\nexport default class Socket extends EventEmitter {\n    /**\n     * Creates a new socket object.\n     */\n    constructor() {\n        super();\n        /** @private */\n        this._id = undefined;\n        /** @private */\n        this._eventEmitter = nativeEventEmitter;\n        /** @type {EventEmitter<'written', any>} @private */\n        this._msgEvtEmitter = new EventEmitter();\n        /** @type {number} @private */\n        this._timeoutMsecs = 0;\n        /** @type {number | undefined} @private */\n        this._timeout = undefined;\n        /** @private */\n        this._encoding = undefined;\n        /** @private */\n        this._msgId = 0;\n        /** @private */\n        this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n        /** @private */\n        this._lastSentMsgId = 0;\n        /** @private */\n        this._paused = false;\n        /** @private */\n        this._resuming = false;\n        /** @private */\n        this._writeBufferSize = 0;\n        /** @private */\n        this._bytesRead = 0;\n        /** @private */\n        this._bytesWritten = 0;\n        /** @private */\n        this._connecting = false;\n        /** @private */\n        this._pending = true;\n        /** @private */\n        this._destroyed = false;\n        // TODO: Add readOnly and writeOnly states\n        /** @type {'opening' | 'open' | 'readOnly' | 'writeOnly'} @private */\n        this._readyState = 'open'; // Incorrect, but matches NodeJS behavior\n        /** @type {{ id: number; data: string; }[]} @private */\n        this._pausedDataEvents = [];\n        this.readableHighWaterMark = 16384;\n        this.writableHighWaterMark = 16384;\n        this.writableNeedDrain = false;\n        this.localAddress = undefined;\n        this.localPort = undefined;\n        this.remoteAddress = undefined;\n        this.remotePort = undefined;\n        this.remoteFamily = undefined;\n        this._registerEvents();\n    }\n\n    get readyState() {\n        return this._readyState;\n    }\n\n    get destroyed() {\n        return this._destroyed;\n    }\n\n    get pending() {\n        return this._pending;\n    }\n\n    get connecting() {\n        return this._connecting;\n    }\n\n    get bytesWritten() {\n        return this._bytesWritten;\n    }\n\n    get bytesRead() {\n        return this._bytesRead;\n    }\n\n    get timeout() {\n        return this._timeout;\n    }\n\n    /**\n     * @package\n     * @param {number} id\n     */\n    _setId(id) {\n        this._id = id;\n        this._registerEvents();\n    }\n\n    /**\n     * @package\n     * @param {NativeConnectionInfo} connectionInfo\n     */\n    _setConnected(connectionInfo) {\n        this._connecting = false;\n        this._readyState = 'open';\n        this._pending = false;\n        this.localAddress = connectionInfo.localAddress;\n        this.localPort = connectionInfo.localPort;\n        this.remoteAddress = connectionInfo.remoteAddress;\n        this.remoteFamily = connectionInfo.remoteFamily;\n        this.remotePort = connectionInfo.remotePort;\n    }\n\n    /**\n     * @param {ConnectionOptions} options\n     * @param {() => void} [callback]\n     */\n    connect(options, callback) {\n        if (this._id === undefined) this._setId(getNextId());\n\n        const customOptions = { ...options };\n        // Normalize args\n        customOptions.host = customOptions.host || 'localhost';\n        customOptions.port = Number(customOptions.port) || 0;\n        this.once('connect', () => {\n            if (callback) callback();\n        });\n        // Timeout\n        if (customOptions.timeout) this.setTimeout(customOptions.timeout);\n        else if (this._timeout) this._activateTimer();\n        // TLS Cert\n        if (customOptions.tlsCert) {\n            customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n        }\n        this._connecting = true;\n        this._readyState = 'opening';\n        Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n        return this;\n    }\n\n    /**\n     * Sets the socket to timeout after `timeout` milliseconds of inactivity on the socket. By default `TcpSocket` do not have a timeout.\n     *\n     * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed.\n     * The user must manually call `socket.end()` or `socket.destroy()` to end the connection.\n     *\n     * If `timeout` is 0, then the existing idle timeout is disabled.\n     *\n     * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n     *\n     * @param {number} timeout\n     * @param {() => void} [callback]\n     */\n    setTimeout(timeout, callback) {\n        if (timeout === 0) {\n            this._clearTimeout();\n        } else {\n            this._activateTimer(timeout);\n        }\n        if (callback) this.once('timeout', callback);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} [timeout]\n     */\n    _activateTimer(timeout) {\n        if (timeout !== undefined) this._timeoutMsecs = timeout;\n        this._clearTimeout();\n        this._timeout = setTimeout(() => {\n            this._clearTimeout();\n            this.emit('timeout');\n        }, this._timeoutMsecs);\n    }\n\n    /**\n     * @private\n     */\n    _clearTimeout() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n    }\n\n    /**\n     * Set the encoding for the socket as a Readable Stream. By default, no encoding is assigned and stream data will be returned as `Buffer` objects.\n     * Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as Buffer objects.\n     *\n     * For instance, calling `socket.setEncoding('utf8')` will cause the output data to be interpreted as UTF-8 data, and passed as strings.\n     * Calling `socket.setEncoding('hex')` will cause the data to be encoded in hexadecimal string format.\n     *\n     * @param {BufferEncoding} [encoding]\n     */\n    setEncoding(encoding) {\n        this._encoding = encoding;\n        return this;\n    }\n\n    /**\n     * Enable/disable the use of Nagle's algorithm. When a TCP connection is created, it will have Nagle's algorithm enabled.\n     *\n     * Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.\n     *\n     * Passing `true` for `noDelay` or not passing an argument will disable Nagle's algorithm for the socket. Passing false for noDelay will enable Nagle's algorithm.\n     *\n     * @param {boolean} noDelay Default: `true`\n     */\n    setNoDelay(noDelay = true) {\n        if (this._pending) {\n            this.once('connect', () => this.setNoDelay(noDelay));\n            return this;\n        }\n        Sockets.setNoDelay(this._id, noDelay);\n        return this;\n    }\n\n    /**\n     * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n     *\n     * `initialDelay` is ignored.\n     *\n     * @param {boolean} enable Default: `false`\n     * @param {number} initialDelay ***IGNORED**. Default: `0`\n     */\n    setKeepAlive(enable = false, initialDelay = 0) {\n        if (this._pending) {\n            this.once('connect', () => this.setKeepAlive(enable, initialDelay));\n            return this;\n        }\n\n        if (initialDelay !== 0) {\n            console.warn(\n                'react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored'\n            );\n        }\n\n        Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n        return this;\n    }\n\n    /**\n     * Returns the bound `address`, the address `family` name and `port` of the socket as reported\n     * by the operating system: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n     *\n     * @returns {AddressInfo | {}}\n     */\n    address() {\n        if (!this.localAddress) return {};\n        return { address: this.localAddress, family: this.remoteFamily, port: this.localPort };\n    }\n\n    /**\n     * Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.\n     *\n     * @param {string | Buffer | Uint8Array} [data]\n     * @param {BufferEncoding} [encoding]\n     */\n    end(data, encoding) {\n        if (data) {\n            this.write(data, encoding, () => {\n                Sockets.end(this._id);\n            });\n            return this;\n        }\n        if (this._pending || this._destroyed) return this;\n\n        this._clearTimeout();\n        Sockets.end(this._id);\n        return this;\n    }\n\n    /**\n     * Ensures that no more I/O activity happens on this socket. Destroys the stream and closes the connection.\n     */\n    destroy() {\n        if (this._pending || this._destroyed) return this;\n        this._destroyed = true;\n        this._clearTimeout();\n        Sockets.destroy(this._id);\n        return this;\n    }\n\n    /**\n     * Sends data on the socket. The second parameter specifies the encoding in the case of a string — it defaults to UTF8 encoding.\n     *\n     * Returns `true` if the entire data was flushed successfully to the kernel buffer. Returns `false` if all or part of the data\n     * was queued in user memory. `'drain'` will be emitted when the buffer is again free.\n     *\n     * The optional callback parameter will be executed when the data is finally written out, which may not be immediately.\n     *\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     * @param {(err?: Error) => void} [cb]\n     *\n     * @return {boolean}\n     */\n    write(buffer, encoding, cb) {\n        const self = this;\n        if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n\n        const generatedBuffer = this._generateSendBuffer(buffer, encoding);\n        this._writeBufferSize += generatedBuffer.byteLength;\n        const currentMsgId = this._msgId;\n        this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n        const msgEvtHandler = (/** @type {{id: number, msgId: number, err?: string}} */ evt) => {\n            const { msgId, err } = evt;\n            if (msgId === currentMsgId) {\n                this._msgEvtEmitter.removeListener('written', msgEvtHandler);\n                this._writeBufferSize -= generatedBuffer.byteLength;\n                this._lastRcvMsgId = msgId;\n                if (self._timeout) self._activateTimer();\n                if (this.writableNeedDrain && this._lastSentMsgId === msgId) {\n                    this.writableNeedDrain = false;\n                    this.emit('drain');\n                }\n                if (cb) {\n                    if (err) cb(new Error(err));\n                    else cb();\n                }\n            }\n        };\n        // Callback equivalent with better performance\n        this._msgEvtEmitter.on('written', msgEvtHandler, this);\n        const ok = this._writeBufferSize < this.writableHighWaterMark;\n        if (!ok) this.writableNeedDrain = true;\n        this._lastSentMsgId = currentMsgId;\n        this._bytesWritten += generatedBuffer.byteLength;\n        Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n        return ok;\n    }\n\n    /**\n     * Pauses the reading of data. That is, `'data'` events will not be emitted. Useful to throttle back an upload.\n     */\n    pause() {\n        if (this._paused) return;\n        this._paused = true;\n        Sockets.pause(this._id);\n        this.emit('pause');\n    }\n\n    /**\n     * Resumes reading after a call to `socket.pause()`.\n     */\n    resume() {\n        if (!this._paused) return;\n        this._paused = false;\n        this.emit('resume');\n        this._recoverDataEventsAfterPause();\n    }\n\n    ref() {\n        console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n    }\n\n    unref() {\n        console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n    }\n\n    /**\n     * @private\n     */\n    async _recoverDataEventsAfterPause() {\n        if (this._resuming) return;\n        this._resuming = true;\n        while (this._pausedDataEvents.length > 0) {\n            // Concat all buffered events for better performance\n            const buffArray = [];\n            let readBytes = 0;\n            let i = 0;\n            for (; i < this._pausedDataEvents.length; i++) {\n                const evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n                readBytes += evtData.byteLength;\n                if (readBytes <= this.readableHighWaterMark) {\n                    buffArray.push(evtData);\n                } else {\n                    const buffOffset = this.readableHighWaterMark - readBytes;\n                    buffArray.push(evtData.slice(0, buffOffset));\n                    this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n                    break;\n                }\n            }\n            // Generate new event with the concatenated events\n            const evt = {\n                id: this._pausedDataEvents[0].id,\n                data: Buffer.concat(buffArray).toString('base64'),\n            };\n            // Clean the old events\n            this._pausedDataEvents = this._pausedDataEvents.slice(i);\n            this._onDeviceDataEvt(evt);\n            if (this._paused) {\n                this._resuming = false;\n                return;\n            }\n        }\n        this._resuming = false;\n        Sockets.resume(this._id);\n    }\n\n    /**\n     * @private\n     */\n    _onDeviceDataEvt = (/** @type {{ id: number; data: string; }} */ evt) => {\n        if (evt.id !== this._id) return;\n        if (!this._paused) {\n            const bufferData = Buffer.from(evt.data, 'base64');\n            this._bytesRead += bufferData.byteLength;\n            const finalData = this._encoding ? bufferData.toString(this._encoding) : bufferData;\n            this.emit('data', finalData);\n        } else {\n            // If the socket is paused, save the data events for later\n            this._pausedDataEvents.push(evt);\n        }\n    };\n\n    /**\n     * @private\n     */\n    _registerEvents() {\n        this._unregisterEvents();\n        this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n        this._errorListener = this._eventEmitter.addListener('error', (evt) => {\n            if (evt.id !== this._id) return;\n            this.destroy();\n            this.emit('error', evt.error);\n        });\n        this._closeListener = this._eventEmitter.addListener('close', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setDisconnected();\n            this.emit('close', evt.error);\n        });\n        this._connectListener = this._eventEmitter.addListener('connect', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setConnected(evt.connection);\n            this.emit('connect');\n        });\n        this._writtenListener = this._eventEmitter.addListener('written', (evt) => {\n            if (evt.id !== this._id) return;\n            this._msgEvtEmitter.emit('written', evt);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _unregisterEvents() {\n        this._dataListener?.remove();\n        this._errorListener?.remove();\n        this._closeListener?.remove();\n        this._connectListener?.remove();\n        this._writtenListener?.remove();\n    }\n\n    /**\n     * @private\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     */\n    _generateSendBuffer(buffer, encoding) {\n        if (typeof buffer === 'string') {\n            return Buffer.from(buffer, encoding);\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n            return Buffer.from(buffer);\n        } else {\n            throw new TypeError(\n                `Invalid data, chunk must be a string or buffer, not ${typeof buffer}`\n            );\n        }\n    }\n\n    /**\n     * @private\n     */\n    _setDisconnected() {\n        this._unregisterEvents();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}