{"ast":null,"code":"'use strict';\n\nimport { NativeModules, Image } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nconst Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {\"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\"} BufferEncoding\n *\n * @typedef {import('react-native').NativeEventEmitter} NativeEventEmitter\n *\n * @typedef {{address: string, family: string, port: number}} AddressInfo\n *\n * @typedef {{localAddress: string, localPort: number, remoteAddress: string, remotePort: number, remoteFamily: string}} NativeConnectionInfo\n *\n * @typedef {{\n * port: number;\n * host?: string;\n * timeout?: number,\n * localAddress?: string,\n * localPort?: number,\n * interface?: 'wifi' | 'cellular' | 'ethernet',\n * reuseAddress?: boolean,\n * tls?: boolean,\n * tlsCheckValidity?: boolean,\n * tlsCert?: any,\n * }} ConnectionOptions\n *\n * @typedef {object} ReadableEvents\n * @property {() => void} pause\n * @property {() => void} resume\n *\n * @typedef {object} SocketEvents\n * @property {(had_error: boolean) => void} close\n * @property {() => void} connect\n * @property {(data: Buffer | string) => void} data\n * @property {() => void} drain\n * @property {(err: Error) => void} error\n * @property {() => void} timeout\n *\n * @extends {EventEmitter<SocketEvents & ReadableEvents, any>}\n */\nexport default class Socket extends EventEmitter {\n  /**\n   * Creates a new socket object.\n   */\n  constructor() {\n    super();\n    /** @private */\n    this._id = undefined;\n    /** @private */\n    this._eventEmitter = nativeEventEmitter;\n    /** @type {EventEmitter<'written', any>} @private */\n    this._msgEvtEmitter = new EventEmitter();\n    /** @type {number} @private */\n    this._timeoutMsecs = 0;\n    /** @type {number | undefined} @private */\n    this._timeout = undefined;\n    /** @private */\n    this._encoding = undefined;\n    /** @private */\n    this._msgId = 0;\n    /** @private */\n    this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n    /** @private */\n    this._lastSentMsgId = 0;\n    /** @private */\n    this._paused = false;\n    /** @private */\n    this._resuming = false;\n    /** @private */\n    this._writeBufferSize = 0;\n    /** @private */\n    this._bytesRead = 0;\n    /** @private */\n    this._bytesWritten = 0;\n    /** @private */\n    this._connecting = false;\n    /** @private */\n    this._pending = true;\n    /** @private */\n    this._destroyed = false;\n    // TODO: Add readOnly and writeOnly states\n    /** @type {'opening' | 'open' | 'readOnly' | 'writeOnly'} @private */\n    this._readyState = 'open'; // Incorrect, but matches NodeJS behavior\n    /** @type {{ id: number; data: string; }[]} @private */\n    this._pausedDataEvents = [];\n    this.readableHighWaterMark = 16384;\n    this.writableHighWaterMark = 16384;\n    this.writableNeedDrain = false;\n    this.localAddress = undefined;\n    this.localPort = undefined;\n    this.remoteAddress = undefined;\n    this.remotePort = undefined;\n    this.remoteFamily = undefined;\n    this._registerEvents();\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  get pending() {\n    return this._pending;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get bytesWritten() {\n    return this._bytesWritten;\n  }\n  get bytesRead() {\n    return this._bytesRead;\n  }\n  get timeout() {\n    return this._timeout;\n  }\n\n  /**\n   * @package\n   * @param {number} id\n   */\n  _setId(id) {\n    this._id = id;\n    this._registerEvents();\n  }\n\n  /**\n   * @package\n   * @param {NativeConnectionInfo} connectionInfo\n   */\n  _setConnected(connectionInfo) {\n    this._connecting = false;\n    this._readyState = 'open';\n    this._pending = false;\n    this.localAddress = connectionInfo.localAddress;\n    this.localPort = connectionInfo.localPort;\n    this.remoteAddress = connectionInfo.remoteAddress;\n    this.remoteFamily = connectionInfo.remoteFamily;\n    this.remotePort = connectionInfo.remotePort;\n  }\n\n  /**\n   * @param {ConnectionOptions} options\n   * @param {() => void} [callback]\n   */\n  connect(options, callback) {\n    if (this._id === undefined) this._setId(getNextId());\n    const customOptions = {\n      ...options\n    };\n    // Normalize args\n    customOptions.host = customOptions.host || 'localhost';\n    customOptions.port = Number(customOptions.port) || 0;\n    this.once('connect', () => {\n      if (callback) callback();\n    });\n    // Timeout\n    if (customOptions.timeout) this.setTimeout(customOptions.timeout);else if (this._timeout) this._activateTimer();\n    // TLS Cert\n    if (customOptions.tlsCert) {\n      customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n    }\n    this._connecting = true;\n    this._readyState = 'opening';\n    Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n    return this;\n  }\n\n  /**\n   * Sets the socket to timeout after `timeout` milliseconds of inactivity on the socket. By default `TcpSocket` do not have a timeout.\n   *\n   * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed.\n   * The user must manually call `socket.end()` or `socket.destroy()` to end the connection.\n   *\n   * If `timeout` is 0, then the existing idle timeout is disabled.\n   *\n   * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n   *\n   * @param {number} timeout\n   * @param {() => void} [callback]\n   */\n  setTimeout(timeout, callback) {\n    if (timeout === 0) {\n      this._clearTimeout();\n    } else {\n      this._activateTimer(timeout);\n    }\n    if (callback) this.once('timeout', callback);\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {number} [timeout]\n   */\n  _activateTimer(timeout) {\n    if (timeout !== undefined) this._timeoutMsecs = timeout;\n    this._clearTimeout();\n    this._timeout = setTimeout(() => {\n      this._clearTimeout();\n      this.emit('timeout');\n    }, this._timeoutMsecs);\n  }\n\n  /**\n   * @private\n   */\n  _clearTimeout() {\n    if (this._timeout !== undefined) {\n      clearTimeout(this._timeout);\n      this._timeout = undefined;\n    }\n  }\n\n  /**\n   * Set the encoding for the socket as a Readable Stream. By default, no encoding is assigned and stream data will be returned as `Buffer` objects.\n   * Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as Buffer objects.\n   *\n   * For instance, calling `socket.setEncoding('utf8')` will cause the output data to be interpreted as UTF-8 data, and passed as strings.\n   * Calling `socket.setEncoding('hex')` will cause the data to be encoded in hexadecimal string format.\n   *\n   * @param {BufferEncoding} [encoding]\n   */\n  setEncoding(encoding) {\n    this._encoding = encoding;\n    return this;\n  }\n\n  /**\n   * Enable/disable the use of Nagle's algorithm. When a TCP connection is created, it will have Nagle's algorithm enabled.\n   *\n   * Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.\n   *\n   * Passing `true` for `noDelay` or not passing an argument will disable Nagle's algorithm for the socket. Passing false for noDelay will enable Nagle's algorithm.\n   *\n   * @param {boolean} noDelay Default: `true`\n   */\n  setNoDelay() {\n    let noDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (this._pending) {\n      this.once('connect', () => this.setNoDelay(noDelay));\n      return this;\n    }\n    Sockets.setNoDelay(this._id, noDelay);\n    return this;\n  }\n\n  /**\n   * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n   *\n   * `initialDelay` is ignored.\n   *\n   * @param {boolean} enable Default: `false`\n   * @param {number} initialDelay ***IGNORED**. Default: `0`\n   */\n  setKeepAlive() {\n    let enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let initialDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this._pending) {\n      this.once('connect', () => this.setKeepAlive(enable, initialDelay));\n      return this;\n    }\n    if (initialDelay !== 0) {\n      console.warn('react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored');\n    }\n    Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n    return this;\n  }\n\n  /**\n   * Returns the bound `address`, the address `family` name and `port` of the socket as reported\n   * by the operating system: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n   *\n   * @returns {AddressInfo | {}}\n   */\n  address() {\n    if (!this.localAddress) return {};\n    return {\n      address: this.localAddress,\n      family: this.remoteFamily,\n      port: this.localPort\n    };\n  }\n\n  /**\n   * Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.\n   *\n   * @param {string | Buffer | Uint8Array} [data]\n   * @param {BufferEncoding} [encoding]\n   */\n  end(data, encoding) {\n    if (data) {\n      this.write(data, encoding, () => {\n        Sockets.end(this._id);\n      });\n      return this;\n    }\n    if (this._pending || this._destroyed) return this;\n    this._clearTimeout();\n    Sockets.end(this._id);\n    return this;\n  }\n\n  /**\n   * Ensures that no more I/O activity happens on this socket. Destroys the stream and closes the connection.\n   */\n  destroy() {\n    if (this._pending || this._destroyed) return this;\n    this._destroyed = true;\n    this._clearTimeout();\n    Sockets.destroy(this._id);\n    return this;\n  }\n\n  /**\n   * Sends data on the socket. The second parameter specifies the encoding in the case of a string — it defaults to UTF8 encoding.\n   *\n   * Returns `true` if the entire data was flushed successfully to the kernel buffer. Returns `false` if all or part of the data\n   * was queued in user memory. `'drain'` will be emitted when the buffer is again free.\n   *\n   * The optional callback parameter will be executed when the data is finally written out, which may not be immediately.\n   *\n   * @param {string | Buffer | Uint8Array} buffer\n   * @param {BufferEncoding} [encoding]\n   * @param {(err?: Error) => void} [cb]\n   *\n   * @return {boolean}\n   */\n  write(buffer, encoding, cb) {\n    const self = this;\n    if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n    const generatedBuffer = this._generateSendBuffer(buffer, encoding);\n    this._writeBufferSize += generatedBuffer.byteLength;\n    const currentMsgId = this._msgId;\n    this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n    const msgEvtHandler = ( /** @type {{id: number, msgId: number, err?: string}} */evt) => {\n      const {\n        msgId,\n        err\n      } = evt;\n      if (msgId === currentMsgId) {\n        this._msgEvtEmitter.removeListener('written', msgEvtHandler);\n        this._writeBufferSize -= generatedBuffer.byteLength;\n        this._lastRcvMsgId = msgId;\n        if (self._timeout) self._activateTimer();\n        if (this.writableNeedDrain && this._lastSentMsgId === msgId) {\n          this.writableNeedDrain = false;\n          this.emit('drain');\n        }\n        if (cb) {\n          if (err) cb(new Error(err));else cb();\n        }\n      }\n    };\n    // Callback equivalent with better performance\n    this._msgEvtEmitter.on('written', msgEvtHandler, this);\n    const ok = this._writeBufferSize < this.writableHighWaterMark;\n    if (!ok) this.writableNeedDrain = true;\n    this._lastSentMsgId = currentMsgId;\n    this._bytesWritten += generatedBuffer.byteLength;\n    Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n    return ok;\n  }\n\n  /**\n   * Pauses the reading of data. That is, `'data'` events will not be emitted. Useful to throttle back an upload.\n   */\n  pause() {\n    if (this._paused) return;\n    this._paused = true;\n    Sockets.pause(this._id);\n    this.emit('pause');\n  }\n\n  /**\n   * Resumes reading after a call to `socket.pause()`.\n   */\n  resume() {\n    if (!this._paused) return;\n    this._paused = false;\n    this.emit('resume');\n    this._recoverDataEventsAfterPause();\n  }\n  ref() {\n    console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n  }\n  unref() {\n    console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n  }\n\n  /**\n   * @private\n   */\n  async _recoverDataEventsAfterPause() {\n    if (this._resuming) return;\n    this._resuming = true;\n    while (this._pausedDataEvents.length > 0) {\n      // Concat all buffered events for better performance\n      const buffArray = [];\n      let readBytes = 0;\n      let i = 0;\n      for (; i < this._pausedDataEvents.length; i++) {\n        const evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n        readBytes += evtData.byteLength;\n        if (readBytes <= this.readableHighWaterMark) {\n          buffArray.push(evtData);\n        } else {\n          const buffOffset = this.readableHighWaterMark - readBytes;\n          buffArray.push(evtData.slice(0, buffOffset));\n          this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n          break;\n        }\n      }\n      // Generate new event with the concatenated events\n      const evt = {\n        id: this._pausedDataEvents[0].id,\n        data: Buffer.concat(buffArray).toString('base64')\n      };\n      // Clean the old events\n      this._pausedDataEvents = this._pausedDataEvents.slice(i);\n      this._onDeviceDataEvt(evt);\n      if (this._paused) {\n        this._resuming = false;\n        return;\n      }\n    }\n    this._resuming = false;\n    Sockets.resume(this._id);\n  }\n\n  /**\n   * @private\n   */\n  _onDeviceDataEvt = ( /** @type {{ id: number; data: string; }} */evt) => {\n    if (evt.id !== this._id) return;\n    if (!this._paused) {\n      const bufferData = Buffer.from(evt.data, 'base64');\n      this._bytesRead += bufferData.byteLength;\n      const finalData = this._encoding ? bufferData.toString(this._encoding) : bufferData;\n      this.emit('data', finalData);\n    } else {\n      // If the socket is paused, save the data events for later\n      this._pausedDataEvents.push(evt);\n    }\n  };\n\n  /**\n   * @private\n   */\n  _registerEvents() {\n    this._unregisterEvents();\n    this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n    this._errorListener = this._eventEmitter.addListener('error', evt => {\n      if (evt.id !== this._id) return;\n      this.destroy();\n      this.emit('error', evt.error);\n    });\n    this._closeListener = this._eventEmitter.addListener('close', evt => {\n      if (evt.id !== this._id) return;\n      this._setDisconnected();\n      this.emit('close', evt.error);\n    });\n    this._connectListener = this._eventEmitter.addListener('connect', evt => {\n      if (evt.id !== this._id) return;\n      this._setConnected(evt.connection);\n      this.emit('connect');\n    });\n    this._writtenListener = this._eventEmitter.addListener('written', evt => {\n      if (evt.id !== this._id) return;\n      this._msgEvtEmitter.emit('written', evt);\n    });\n  }\n\n  /**\n   * @private\n   */\n  _unregisterEvents() {\n    this._dataListener?.remove();\n    this._errorListener?.remove();\n    this._closeListener?.remove();\n    this._connectListener?.remove();\n    this._writtenListener?.remove();\n  }\n\n  /**\n   * @private\n   * @param {string | Buffer | Uint8Array} buffer\n   * @param {BufferEncoding} [encoding]\n   */\n  _generateSendBuffer(buffer, encoding) {\n    if (typeof buffer === 'string') {\n      return Buffer.from(buffer, encoding);\n    } else if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n      return Buffer.from(buffer);\n    } else {\n      throw new TypeError(`Invalid data, chunk must be a string or buffer, not ${typeof buffer}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _setDisconnected() {\n    this._unregisterEvents();\n  }\n}","map":{"version":3,"names":["NativeModules","Image","EventEmitter","Buffer","Sockets","TcpSockets","nativeEventEmitter","getNextId","Socket","constructor","_id","undefined","_eventEmitter","_msgEvtEmitter","_timeoutMsecs","_timeout","_encoding","_msgId","_lastRcvMsgId","Number","MAX_SAFE_INTEGER","_lastSentMsgId","_paused","_resuming","_writeBufferSize","_bytesRead","_bytesWritten","_connecting","_pending","_destroyed","_readyState","_pausedDataEvents","readableHighWaterMark","writableHighWaterMark","writableNeedDrain","localAddress","localPort","remoteAddress","remotePort","remoteFamily","_registerEvents","readyState","destroyed","pending","connecting","bytesWritten","bytesRead","timeout","_setId","id","_setConnected","connectionInfo","connect","options","callback","customOptions","host","port","once","setTimeout","_activateTimer","tlsCert","resolveAssetSource","uri","_clearTimeout","emit","clearTimeout","setEncoding","encoding","setNoDelay","noDelay","arguments","length","setKeepAlive","enable","initialDelay","console","warn","Math","floor","address","family","end","data","write","destroy","buffer","cb","self","Error","generatedBuffer","_generateSendBuffer","byteLength","currentMsgId","msgEvtHandler","evt","msgId","err","removeListener","on","ok","toString","pause","resume","_recoverDataEventsAfterPause","ref","unref","buffArray","readBytes","i","evtData","from","push","buffOffset","slice","concat","_onDeviceDataEvt","bufferData","finalData","_unregisterEvents","_dataListener","addListener","_errorListener","error","_closeListener","_setDisconnected","_connectListener","connection","_writtenListener","remove","isBuffer","Uint8Array","Array","isArray","TypeError"],"sources":["/home/ywha/WEB_FLUID/react_proxy/node_modules/react-native-tcp-socket/src/Socket.js"],"sourcesContent":["'use strict';\n\nimport { NativeModules, Image } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nconst Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {\"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\"} BufferEncoding\n *\n * @typedef {import('react-native').NativeEventEmitter} NativeEventEmitter\n *\n * @typedef {{address: string, family: string, port: number}} AddressInfo\n *\n * @typedef {{localAddress: string, localPort: number, remoteAddress: string, remotePort: number, remoteFamily: string}} NativeConnectionInfo\n *\n * @typedef {{\n * port: number;\n * host?: string;\n * timeout?: number,\n * localAddress?: string,\n * localPort?: number,\n * interface?: 'wifi' | 'cellular' | 'ethernet',\n * reuseAddress?: boolean,\n * tls?: boolean,\n * tlsCheckValidity?: boolean,\n * tlsCert?: any,\n * }} ConnectionOptions\n *\n * @typedef {object} ReadableEvents\n * @property {() => void} pause\n * @property {() => void} resume\n *\n * @typedef {object} SocketEvents\n * @property {(had_error: boolean) => void} close\n * @property {() => void} connect\n * @property {(data: Buffer | string) => void} data\n * @property {() => void} drain\n * @property {(err: Error) => void} error\n * @property {() => void} timeout\n *\n * @extends {EventEmitter<SocketEvents & ReadableEvents, any>}\n */\nexport default class Socket extends EventEmitter {\n    /**\n     * Creates a new socket object.\n     */\n    constructor() {\n        super();\n        /** @private */\n        this._id = undefined;\n        /** @private */\n        this._eventEmitter = nativeEventEmitter;\n        /** @type {EventEmitter<'written', any>} @private */\n        this._msgEvtEmitter = new EventEmitter();\n        /** @type {number} @private */\n        this._timeoutMsecs = 0;\n        /** @type {number | undefined} @private */\n        this._timeout = undefined;\n        /** @private */\n        this._encoding = undefined;\n        /** @private */\n        this._msgId = 0;\n        /** @private */\n        this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n        /** @private */\n        this._lastSentMsgId = 0;\n        /** @private */\n        this._paused = false;\n        /** @private */\n        this._resuming = false;\n        /** @private */\n        this._writeBufferSize = 0;\n        /** @private */\n        this._bytesRead = 0;\n        /** @private */\n        this._bytesWritten = 0;\n        /** @private */\n        this._connecting = false;\n        /** @private */\n        this._pending = true;\n        /** @private */\n        this._destroyed = false;\n        // TODO: Add readOnly and writeOnly states\n        /** @type {'opening' | 'open' | 'readOnly' | 'writeOnly'} @private */\n        this._readyState = 'open'; // Incorrect, but matches NodeJS behavior\n        /** @type {{ id: number; data: string; }[]} @private */\n        this._pausedDataEvents = [];\n        this.readableHighWaterMark = 16384;\n        this.writableHighWaterMark = 16384;\n        this.writableNeedDrain = false;\n        this.localAddress = undefined;\n        this.localPort = undefined;\n        this.remoteAddress = undefined;\n        this.remotePort = undefined;\n        this.remoteFamily = undefined;\n        this._registerEvents();\n    }\n\n    get readyState() {\n        return this._readyState;\n    }\n\n    get destroyed() {\n        return this._destroyed;\n    }\n\n    get pending() {\n        return this._pending;\n    }\n\n    get connecting() {\n        return this._connecting;\n    }\n\n    get bytesWritten() {\n        return this._bytesWritten;\n    }\n\n    get bytesRead() {\n        return this._bytesRead;\n    }\n\n    get timeout() {\n        return this._timeout;\n    }\n\n    /**\n     * @package\n     * @param {number} id\n     */\n    _setId(id) {\n        this._id = id;\n        this._registerEvents();\n    }\n\n    /**\n     * @package\n     * @param {NativeConnectionInfo} connectionInfo\n     */\n    _setConnected(connectionInfo) {\n        this._connecting = false;\n        this._readyState = 'open';\n        this._pending = false;\n        this.localAddress = connectionInfo.localAddress;\n        this.localPort = connectionInfo.localPort;\n        this.remoteAddress = connectionInfo.remoteAddress;\n        this.remoteFamily = connectionInfo.remoteFamily;\n        this.remotePort = connectionInfo.remotePort;\n    }\n\n    /**\n     * @param {ConnectionOptions} options\n     * @param {() => void} [callback]\n     */\n    connect(options, callback) {\n        if (this._id === undefined) this._setId(getNextId());\n\n        const customOptions = { ...options };\n        // Normalize args\n        customOptions.host = customOptions.host || 'localhost';\n        customOptions.port = Number(customOptions.port) || 0;\n        this.once('connect', () => {\n            if (callback) callback();\n        });\n        // Timeout\n        if (customOptions.timeout) this.setTimeout(customOptions.timeout);\n        else if (this._timeout) this._activateTimer();\n        // TLS Cert\n        if (customOptions.tlsCert) {\n            customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n        }\n        this._connecting = true;\n        this._readyState = 'opening';\n        Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n        return this;\n    }\n\n    /**\n     * Sets the socket to timeout after `timeout` milliseconds of inactivity on the socket. By default `TcpSocket` do not have a timeout.\n     *\n     * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed.\n     * The user must manually call `socket.end()` or `socket.destroy()` to end the connection.\n     *\n     * If `timeout` is 0, then the existing idle timeout is disabled.\n     *\n     * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n     *\n     * @param {number} timeout\n     * @param {() => void} [callback]\n     */\n    setTimeout(timeout, callback) {\n        if (timeout === 0) {\n            this._clearTimeout();\n        } else {\n            this._activateTimer(timeout);\n        }\n        if (callback) this.once('timeout', callback);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} [timeout]\n     */\n    _activateTimer(timeout) {\n        if (timeout !== undefined) this._timeoutMsecs = timeout;\n        this._clearTimeout();\n        this._timeout = setTimeout(() => {\n            this._clearTimeout();\n            this.emit('timeout');\n        }, this._timeoutMsecs);\n    }\n\n    /**\n     * @private\n     */\n    _clearTimeout() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n    }\n\n    /**\n     * Set the encoding for the socket as a Readable Stream. By default, no encoding is assigned and stream data will be returned as `Buffer` objects.\n     * Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as Buffer objects.\n     *\n     * For instance, calling `socket.setEncoding('utf8')` will cause the output data to be interpreted as UTF-8 data, and passed as strings.\n     * Calling `socket.setEncoding('hex')` will cause the data to be encoded in hexadecimal string format.\n     *\n     * @param {BufferEncoding} [encoding]\n     */\n    setEncoding(encoding) {\n        this._encoding = encoding;\n        return this;\n    }\n\n    /**\n     * Enable/disable the use of Nagle's algorithm. When a TCP connection is created, it will have Nagle's algorithm enabled.\n     *\n     * Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.\n     *\n     * Passing `true` for `noDelay` or not passing an argument will disable Nagle's algorithm for the socket. Passing false for noDelay will enable Nagle's algorithm.\n     *\n     * @param {boolean} noDelay Default: `true`\n     */\n    setNoDelay(noDelay = true) {\n        if (this._pending) {\n            this.once('connect', () => this.setNoDelay(noDelay));\n            return this;\n        }\n        Sockets.setNoDelay(this._id, noDelay);\n        return this;\n    }\n\n    /**\n     * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n     *\n     * `initialDelay` is ignored.\n     *\n     * @param {boolean} enable Default: `false`\n     * @param {number} initialDelay ***IGNORED**. Default: `0`\n     */\n    setKeepAlive(enable = false, initialDelay = 0) {\n        if (this._pending) {\n            this.once('connect', () => this.setKeepAlive(enable, initialDelay));\n            return this;\n        }\n\n        if (initialDelay !== 0) {\n            console.warn(\n                'react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored'\n            );\n        }\n\n        Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n        return this;\n    }\n\n    /**\n     * Returns the bound `address`, the address `family` name and `port` of the socket as reported\n     * by the operating system: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n     *\n     * @returns {AddressInfo | {}}\n     */\n    address() {\n        if (!this.localAddress) return {};\n        return { address: this.localAddress, family: this.remoteFamily, port: this.localPort };\n    }\n\n    /**\n     * Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.\n     *\n     * @param {string | Buffer | Uint8Array} [data]\n     * @param {BufferEncoding} [encoding]\n     */\n    end(data, encoding) {\n        if (data) {\n            this.write(data, encoding, () => {\n                Sockets.end(this._id);\n            });\n            return this;\n        }\n        if (this._pending || this._destroyed) return this;\n\n        this._clearTimeout();\n        Sockets.end(this._id);\n        return this;\n    }\n\n    /**\n     * Ensures that no more I/O activity happens on this socket. Destroys the stream and closes the connection.\n     */\n    destroy() {\n        if (this._pending || this._destroyed) return this;\n        this._destroyed = true;\n        this._clearTimeout();\n        Sockets.destroy(this._id);\n        return this;\n    }\n\n    /**\n     * Sends data on the socket. The second parameter specifies the encoding in the case of a string — it defaults to UTF8 encoding.\n     *\n     * Returns `true` if the entire data was flushed successfully to the kernel buffer. Returns `false` if all or part of the data\n     * was queued in user memory. `'drain'` will be emitted when the buffer is again free.\n     *\n     * The optional callback parameter will be executed when the data is finally written out, which may not be immediately.\n     *\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     * @param {(err?: Error) => void} [cb]\n     *\n     * @return {boolean}\n     */\n    write(buffer, encoding, cb) {\n        const self = this;\n        if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n\n        const generatedBuffer = this._generateSendBuffer(buffer, encoding);\n        this._writeBufferSize += generatedBuffer.byteLength;\n        const currentMsgId = this._msgId;\n        this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n        const msgEvtHandler = (/** @type {{id: number, msgId: number, err?: string}} */ evt) => {\n            const { msgId, err } = evt;\n            if (msgId === currentMsgId) {\n                this._msgEvtEmitter.removeListener('written', msgEvtHandler);\n                this._writeBufferSize -= generatedBuffer.byteLength;\n                this._lastRcvMsgId = msgId;\n                if (self._timeout) self._activateTimer();\n                if (this.writableNeedDrain && this._lastSentMsgId === msgId) {\n                    this.writableNeedDrain = false;\n                    this.emit('drain');\n                }\n                if (cb) {\n                    if (err) cb(new Error(err));\n                    else cb();\n                }\n            }\n        };\n        // Callback equivalent with better performance\n        this._msgEvtEmitter.on('written', msgEvtHandler, this);\n        const ok = this._writeBufferSize < this.writableHighWaterMark;\n        if (!ok) this.writableNeedDrain = true;\n        this._lastSentMsgId = currentMsgId;\n        this._bytesWritten += generatedBuffer.byteLength;\n        Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n        return ok;\n    }\n\n    /**\n     * Pauses the reading of data. That is, `'data'` events will not be emitted. Useful to throttle back an upload.\n     */\n    pause() {\n        if (this._paused) return;\n        this._paused = true;\n        Sockets.pause(this._id);\n        this.emit('pause');\n    }\n\n    /**\n     * Resumes reading after a call to `socket.pause()`.\n     */\n    resume() {\n        if (!this._paused) return;\n        this._paused = false;\n        this.emit('resume');\n        this._recoverDataEventsAfterPause();\n    }\n\n    ref() {\n        console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n    }\n\n    unref() {\n        console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n    }\n\n    /**\n     * @private\n     */\n    async _recoverDataEventsAfterPause() {\n        if (this._resuming) return;\n        this._resuming = true;\n        while (this._pausedDataEvents.length > 0) {\n            // Concat all buffered events for better performance\n            const buffArray = [];\n            let readBytes = 0;\n            let i = 0;\n            for (; i < this._pausedDataEvents.length; i++) {\n                const evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n                readBytes += evtData.byteLength;\n                if (readBytes <= this.readableHighWaterMark) {\n                    buffArray.push(evtData);\n                } else {\n                    const buffOffset = this.readableHighWaterMark - readBytes;\n                    buffArray.push(evtData.slice(0, buffOffset));\n                    this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n                    break;\n                }\n            }\n            // Generate new event with the concatenated events\n            const evt = {\n                id: this._pausedDataEvents[0].id,\n                data: Buffer.concat(buffArray).toString('base64'),\n            };\n            // Clean the old events\n            this._pausedDataEvents = this._pausedDataEvents.slice(i);\n            this._onDeviceDataEvt(evt);\n            if (this._paused) {\n                this._resuming = false;\n                return;\n            }\n        }\n        this._resuming = false;\n        Sockets.resume(this._id);\n    }\n\n    /**\n     * @private\n     */\n    _onDeviceDataEvt = (/** @type {{ id: number; data: string; }} */ evt) => {\n        if (evt.id !== this._id) return;\n        if (!this._paused) {\n            const bufferData = Buffer.from(evt.data, 'base64');\n            this._bytesRead += bufferData.byteLength;\n            const finalData = this._encoding ? bufferData.toString(this._encoding) : bufferData;\n            this.emit('data', finalData);\n        } else {\n            // If the socket is paused, save the data events for later\n            this._pausedDataEvents.push(evt);\n        }\n    };\n\n    /**\n     * @private\n     */\n    _registerEvents() {\n        this._unregisterEvents();\n        this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n        this._errorListener = this._eventEmitter.addListener('error', (evt) => {\n            if (evt.id !== this._id) return;\n            this.destroy();\n            this.emit('error', evt.error);\n        });\n        this._closeListener = this._eventEmitter.addListener('close', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setDisconnected();\n            this.emit('close', evt.error);\n        });\n        this._connectListener = this._eventEmitter.addListener('connect', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setConnected(evt.connection);\n            this.emit('connect');\n        });\n        this._writtenListener = this._eventEmitter.addListener('written', (evt) => {\n            if (evt.id !== this._id) return;\n            this._msgEvtEmitter.emit('written', evt);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _unregisterEvents() {\n        this._dataListener?.remove();\n        this._errorListener?.remove();\n        this._closeListener?.remove();\n        this._connectListener?.remove();\n        this._writtenListener?.remove();\n    }\n\n    /**\n     * @private\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     */\n    _generateSendBuffer(buffer, encoding) {\n        if (typeof buffer === 'string') {\n            return Buffer.from(buffer, encoding);\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n            return Buffer.from(buffer);\n        } else {\n            throw new TypeError(\n                `Invalid data, chunk must be a string or buffer, not ${typeof buffer}`\n            );\n        }\n    }\n\n    /**\n     * @private\n     */\n    _setDisconnected() {\n        this._unregisterEvents();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}