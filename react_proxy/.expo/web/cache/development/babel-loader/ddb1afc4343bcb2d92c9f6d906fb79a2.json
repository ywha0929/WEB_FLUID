{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.keyExtractor = keyExtractor;\nexports.newRangeCount = newRangeCount;\n\nfunction elementsThatOverlapOffsets(offsets, props, getFrameMetrics, zoomScale) {\n  if (zoomScale === void 0) {\n    zoomScale = 1;\n  }\n\n  var itemCount = props.getItemCount(props.data);\n  var result = [];\n\n  for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    var currentOffset = offsets[offsetIndex];\n    var left = 0;\n    var right = itemCount - 1;\n\n    while (left <= right) {\n      var mid = left + (right - left >>> 1);\n      var frame = getFrameMetrics(mid, props);\n      var scaledOffsetStart = frame.offset * zoomScale;\n      var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n\nfunction computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = props.getItemCount(props.data);\n\n  if (itemCount === 0) {\n    return {\n      first: 0,\n      last: -1\n    };\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength,\n      _scrollMetrics$zoomSc = scrollMetrics.zoomScale,\n      zoomScale = _scrollMetrics$zoomSc === void 0 ? 1 : _scrollMetrics$zoomSc;\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n  var leadFactor = 0.5;\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;\n\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  };\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nfunction keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n\n  return String(index);\n}","map":{"version":3,"names":["elementsThatOverlapOffsets","offsets","props","getFrameMetrics","zoomScale","itemCount","getItemCount","data","result","offsetIndex","length","currentOffset","left","right","mid","frame","scaledOffsetStart","offset","scaledOffsetEnd","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","maxToRenderPerBatch","windowSize","getFrameMetricsApprox","scrollMetrics","velocity","visibleLength","_scrollMetrics$zoomSc","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","JSON","stringify","keyExtractor","item","index","key","id","String"],"sources":["/home/ywha/WEB_FLUID/react_proxy/node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(offsets, props, getFrameMetrics, zoomScale) {\n  if (zoomScale === void 0) {\n    zoomScale = 1;\n  }\n  var itemCount = props.getItemCount(props.data);\n  var result = [];\n  for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    var currentOffset = offsets[offsetIndex];\n    var left = 0;\n    var right = itemCount - 1;\n    while (left <= right) {\n      // eslint-disable-next-line no-bitwise\n      var mid = left + (right - left >>> 1);\n      var frame = getFrameMetrics(mid, props);\n      var scaledOffsetStart = frame.offset * zoomScale;\n      var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\n      if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {\n      first: 0,\n      last: -1\n    };\n  }\n  var offset = scrollMetrics.offset,\n    velocity = scrollMetrics.velocity,\n    visibleLength = scrollMetrics.visibleLength,\n    _scrollMetrics$zoomSc = scrollMetrics.zoomScale,\n    zoomScale = _scrollMetrics$zoomSc === void 0 ? 1 : _scrollMetrics$zoomSc;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),\n    overscanFirst = _elementsThatOverlapO[0],\n    first = _elementsThatOverlapO[1],\n    last = _elementsThatOverlapO[2],\n    overscanLast = _elementsThatOverlapO[3];\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first,\n    last\n  };\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  var newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first,\n      last,\n      itemCount,\n      overscanFirst,\n      overscanLast,\n      visible\n    }));\n  }\n  return {\n    first,\n    last\n  };\n}\nexport function keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n  return String(index);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}