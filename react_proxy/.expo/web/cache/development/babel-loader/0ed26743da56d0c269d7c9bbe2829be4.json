{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _eventemitter = _interopRequireDefault(require(\"eventemitter3\"));\n\nvar _buffer = require(\"buffer\");\n\nvar _Globals = require(\"./Globals\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Sockets = _reactNative.NativeModules.TcpSockets;\n\nvar Socket = function (_EventEmitter) {\n  (0, _inherits2.default)(Socket, _EventEmitter);\n\n  var _super = _createSuper(Socket);\n\n  function Socket() {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Socket);\n    _this = _super.call(this);\n\n    _this._onDeviceDataEvt = function (evt) {\n      if (evt.id !== _this._id) return;\n\n      if (!_this._paused) {\n        var bufferData = _buffer.Buffer.from(evt.data, 'base64');\n\n        _this._bytesRead += bufferData.byteLength;\n        var finalData = _this._encoding ? bufferData.toString(_this._encoding) : bufferData;\n\n        _this.emit('data', finalData);\n      } else {\n        _this._pausedDataEvents.push(evt);\n      }\n    };\n\n    _this._id = undefined;\n    _this._eventEmitter = _Globals.nativeEventEmitter;\n    _this._msgEvtEmitter = new _eventemitter.default();\n    _this._timeoutMsecs = 0;\n    _this._timeout = undefined;\n    _this._encoding = undefined;\n    _this._msgId = 0;\n    _this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n    _this._lastSentMsgId = 0;\n    _this._paused = false;\n    _this._resuming = false;\n    _this._writeBufferSize = 0;\n    _this._bytesRead = 0;\n    _this._bytesWritten = 0;\n    _this._connecting = false;\n    _this._pending = true;\n    _this._destroyed = false;\n    _this._readyState = 'open';\n    _this._pausedDataEvents = [];\n    _this.readableHighWaterMark = 16384;\n    _this.writableHighWaterMark = 16384;\n    _this.writableNeedDrain = false;\n    _this.localAddress = undefined;\n    _this.localPort = undefined;\n    _this.remoteAddress = undefined;\n    _this.remotePort = undefined;\n    _this.remoteFamily = undefined;\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(Socket, [{\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this._destroyed;\n    }\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._pending;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this._connecting;\n    }\n  }, {\n    key: \"bytesWritten\",\n    get: function get() {\n      return this._bytesWritten;\n    }\n  }, {\n    key: \"bytesRead\",\n    get: function get() {\n      return this._bytesRead;\n    }\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return this._timeout;\n    }\n  }, {\n    key: \"_setId\",\n    value: function _setId(id) {\n      this._id = id;\n\n      this._registerEvents();\n    }\n  }, {\n    key: \"_setConnected\",\n    value: function _setConnected(connectionInfo) {\n      this._connecting = false;\n      this._readyState = 'open';\n      this._pending = false;\n      this.localAddress = connectionInfo.localAddress;\n      this.localPort = connectionInfo.localPort;\n      this.remoteAddress = connectionInfo.remoteAddress;\n      this.remoteFamily = connectionInfo.remoteFamily;\n      this.remotePort = connectionInfo.remotePort;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(options, callback) {\n      if (this._id === undefined) this._setId((0, _Globals.getNextId)());\n      var customOptions = Object.assign({}, options);\n      customOptions.host = customOptions.host || 'localhost';\n      customOptions.port = Number(customOptions.port) || 0;\n      this.once('connect', function () {\n        if (callback) callback();\n      });\n      if (customOptions.timeout) this.setTimeout(customOptions.timeout);else if (this._timeout) this._activateTimer();\n\n      if (customOptions.tlsCert) {\n        customOptions.tlsCert = _reactNative.Image.resolveAssetSource(customOptions.tlsCert).uri;\n      }\n\n      this._connecting = true;\n      this._readyState = 'opening';\n      Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n      return this;\n    }\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(timeout, callback) {\n      if (timeout === 0) {\n        this._clearTimeout();\n      } else {\n        this._activateTimer(timeout);\n      }\n\n      if (callback) this.once('timeout', callback);\n      return this;\n    }\n  }, {\n    key: \"_activateTimer\",\n    value: function _activateTimer(timeout) {\n      var _this2 = this;\n\n      if (timeout !== undefined) this._timeoutMsecs = timeout;\n\n      this._clearTimeout();\n\n      this._timeout = setTimeout(function () {\n        _this2._clearTimeout();\n\n        _this2.emit('timeout');\n      }, this._timeoutMsecs);\n    }\n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout() {\n      if (this._timeout !== undefined) {\n        clearTimeout(this._timeout);\n        this._timeout = undefined;\n      }\n    }\n  }, {\n    key: \"setEncoding\",\n    value: function setEncoding(encoding) {\n      this._encoding = encoding;\n      return this;\n    }\n  }, {\n    key: \"setNoDelay\",\n    value: function setNoDelay() {\n      var _this3 = this;\n\n      var noDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this._pending) {\n        this.once('connect', function () {\n          return _this3.setNoDelay(noDelay);\n        });\n        return this;\n      }\n\n      Sockets.setNoDelay(this._id, noDelay);\n      return this;\n    }\n  }, {\n    key: \"setKeepAlive\",\n    value: function setKeepAlive() {\n      var _this4 = this;\n\n      var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var initialDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this._pending) {\n        this.once('connect', function () {\n          return _this4.setKeepAlive(enable, initialDelay);\n        });\n        return this;\n      }\n\n      if (initialDelay !== 0) {\n        console.warn('react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored');\n      }\n\n      Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n      return this;\n    }\n  }, {\n    key: \"address\",\n    value: function address() {\n      if (!this.localAddress) return {};\n      return {\n        address: this.localAddress,\n        family: this.remoteFamily,\n        port: this.localPort\n      };\n    }\n  }, {\n    key: \"end\",\n    value: function end(data, encoding) {\n      var _this5 = this;\n\n      if (data) {\n        this.write(data, encoding, function () {\n          Sockets.end(_this5._id);\n        });\n        return this;\n      }\n\n      if (this._pending || this._destroyed) return this;\n\n      this._clearTimeout();\n\n      Sockets.end(this._id);\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._pending || this._destroyed) return this;\n      this._destroyed = true;\n\n      this._clearTimeout();\n\n      Sockets.destroy(this._id);\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(buffer, encoding, cb) {\n      var _this6 = this;\n\n      var self = this;\n      if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n\n      var generatedBuffer = this._generateSendBuffer(buffer, encoding);\n\n      this._writeBufferSize += generatedBuffer.byteLength;\n      var currentMsgId = this._msgId;\n      this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n\n      var msgEvtHandler = function msgEvtHandler(evt) {\n        var msgId = evt.msgId,\n            err = evt.err;\n\n        if (msgId === currentMsgId) {\n          _this6._msgEvtEmitter.removeListener('written', msgEvtHandler);\n\n          _this6._writeBufferSize -= generatedBuffer.byteLength;\n          _this6._lastRcvMsgId = msgId;\n          if (self._timeout) self._activateTimer();\n\n          if (_this6.writableNeedDrain && _this6._lastSentMsgId === msgId) {\n            _this6.writableNeedDrain = false;\n\n            _this6.emit('drain');\n          }\n\n          if (cb) {\n            if (err) cb(new Error(err));else cb();\n          }\n        }\n      };\n\n      this._msgEvtEmitter.on('written', msgEvtHandler, this);\n\n      var ok = this._writeBufferSize < this.writableHighWaterMark;\n      if (!ok) this.writableNeedDrain = true;\n      this._lastSentMsgId = currentMsgId;\n      this._bytesWritten += generatedBuffer.byteLength;\n      Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n      return ok;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this._paused) return;\n      this._paused = true;\n      Sockets.pause(this._id);\n      this.emit('pause');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (!this._paused) return;\n      this._paused = false;\n      this.emit('resume');\n\n      this._recoverDataEventsAfterPause();\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n    }\n  }, {\n    key: \"_recoverDataEventsAfterPause\",\n    value: function () {\n      var _recoverDataEventsAfterPause2 = (0, _asyncToGenerator2.default)(function* () {\n        if (this._resuming) return;\n        this._resuming = true;\n\n        while (this._pausedDataEvents.length > 0) {\n          var buffArray = [];\n          var readBytes = 0;\n          var i = 0;\n\n          for (; i < this._pausedDataEvents.length; i++) {\n            var evtData = _buffer.Buffer.from(this._pausedDataEvents[i].data, 'base64');\n\n            readBytes += evtData.byteLength;\n\n            if (readBytes <= this.readableHighWaterMark) {\n              buffArray.push(evtData);\n            } else {\n              var buffOffset = this.readableHighWaterMark - readBytes;\n              buffArray.push(evtData.slice(0, buffOffset));\n              this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n              break;\n            }\n          }\n\n          var evt = {\n            id: this._pausedDataEvents[0].id,\n            data: _buffer.Buffer.concat(buffArray).toString('base64')\n          };\n          this._pausedDataEvents = this._pausedDataEvents.slice(i);\n\n          this._onDeviceDataEvt(evt);\n\n          if (this._paused) {\n            this._resuming = false;\n            return;\n          }\n        }\n\n        this._resuming = false;\n        Sockets.resume(this._id);\n      });\n\n      function _recoverDataEventsAfterPause() {\n        return _recoverDataEventsAfterPause2.apply(this, arguments);\n      }\n\n      return _recoverDataEventsAfterPause;\n    }()\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this7 = this;\n\n      this._unregisterEvents();\n\n      this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n      this._errorListener = this._eventEmitter.addListener('error', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7.destroy();\n\n        _this7.emit('error', evt.error);\n      });\n      this._closeListener = this._eventEmitter.addListener('close', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7._setDisconnected();\n\n        _this7.emit('close', evt.error);\n      });\n      this._connectListener = this._eventEmitter.addListener('connect', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7._setConnected(evt.connection);\n\n        _this7.emit('connect');\n      });\n      this._writtenListener = this._eventEmitter.addListener('written', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7._msgEvtEmitter.emit('written', evt);\n      });\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      var _this$_dataListener, _this$_errorListener, _this$_closeListener, _this$_connectListene, _this$_writtenListene;\n\n      (_this$_dataListener = this._dataListener) == null ? void 0 : _this$_dataListener.remove();\n      (_this$_errorListener = this._errorListener) == null ? void 0 : _this$_errorListener.remove();\n      (_this$_closeListener = this._closeListener) == null ? void 0 : _this$_closeListener.remove();\n      (_this$_connectListene = this._connectListener) == null ? void 0 : _this$_connectListene.remove();\n      (_this$_writtenListene = this._writtenListener) == null ? void 0 : _this$_writtenListene.remove();\n    }\n  }, {\n    key: \"_generateSendBuffer\",\n    value: function _generateSendBuffer(buffer, encoding) {\n      if (typeof buffer === 'string') {\n        return _buffer.Buffer.from(buffer, encoding);\n      } else if (_buffer.Buffer.isBuffer(buffer)) {\n        return buffer;\n      } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n        return _buffer.Buffer.from(buffer);\n      } else {\n        throw new TypeError(\"Invalid data, chunk must be a string or buffer, not \" + typeof buffer);\n      }\n    }\n  }, {\n    key: \"_setDisconnected\",\n    value: function _setDisconnected() {\n      this._unregisterEvents();\n    }\n  }]);\n  return Socket;\n}(_eventemitter.default);\n\nexports.default = Socket;","map":{"version":3,"names":["Sockets","NativeModules","TcpSockets","Socket","_onDeviceDataEvt","evt","id","_id","_paused","bufferData","Buffer","from","data","_bytesRead","byteLength","finalData","_encoding","toString","emit","_pausedDataEvents","push","undefined","_eventEmitter","nativeEventEmitter","_msgEvtEmitter","EventEmitter","_timeoutMsecs","_timeout","_msgId","_lastRcvMsgId","Number","MAX_SAFE_INTEGER","_lastSentMsgId","_resuming","_writeBufferSize","_bytesWritten","_connecting","_pending","_destroyed","_readyState","readableHighWaterMark","writableHighWaterMark","writableNeedDrain","localAddress","localPort","remoteAddress","remotePort","remoteFamily","_registerEvents","connectionInfo","options","callback","_setId","getNextId","customOptions","host","port","once","timeout","setTimeout","_activateTimer","tlsCert","Image","resolveAssetSource","uri","connect","_clearTimeout","clearTimeout","encoding","noDelay","setNoDelay","enable","initialDelay","setKeepAlive","console","warn","Math","floor","address","family","write","end","destroy","buffer","cb","self","Error","generatedBuffer","_generateSendBuffer","currentMsgId","msgEvtHandler","msgId","err","removeListener","on","ok","pause","_recoverDataEventsAfterPause","length","buffArray","readBytes","i","evtData","buffOffset","slice","concat","resume","_unregisterEvents","_dataListener","addListener","_errorListener","error","_closeListener","_setDisconnected","_connectListener","_setConnected","connection","_writtenListener","remove","isBuffer","Uint8Array","Array","isArray","TypeError"],"sources":["/home/ywha/WEB_FLUID/react_proxy/node_modules/react-native-tcp-socket/src/Socket.js"],"sourcesContent":["'use strict';\n\nimport { NativeModules, Image } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nconst Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {\"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\"} BufferEncoding\n *\n * @typedef {import('react-native').NativeEventEmitter} NativeEventEmitter\n *\n * @typedef {{address: string, family: string, port: number}} AddressInfo\n *\n * @typedef {{localAddress: string, localPort: number, remoteAddress: string, remotePort: number, remoteFamily: string}} NativeConnectionInfo\n *\n * @typedef {{\n * port: number;\n * host?: string;\n * timeout?: number,\n * localAddress?: string,\n * localPort?: number,\n * interface?: 'wifi' | 'cellular' | 'ethernet',\n * reuseAddress?: boolean,\n * tls?: boolean,\n * tlsCheckValidity?: boolean,\n * tlsCert?: any,\n * }} ConnectionOptions\n *\n * @typedef {object} ReadableEvents\n * @property {() => void} pause\n * @property {() => void} resume\n *\n * @typedef {object} SocketEvents\n * @property {(had_error: boolean) => void} close\n * @property {() => void} connect\n * @property {(data: Buffer | string) => void} data\n * @property {() => void} drain\n * @property {(err: Error) => void} error\n * @property {() => void} timeout\n *\n * @extends {EventEmitter<SocketEvents & ReadableEvents, any>}\n */\nexport default class Socket extends EventEmitter {\n    /**\n     * Creates a new socket object.\n     */\n    constructor() {\n        super();\n        /** @private */\n        this._id = undefined;\n        /** @private */\n        this._eventEmitter = nativeEventEmitter;\n        /** @type {EventEmitter<'written', any>} @private */\n        this._msgEvtEmitter = new EventEmitter();\n        /** @type {number} @private */\n        this._timeoutMsecs = 0;\n        /** @type {number | undefined} @private */\n        this._timeout = undefined;\n        /** @private */\n        this._encoding = undefined;\n        /** @private */\n        this._msgId = 0;\n        /** @private */\n        this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n        /** @private */\n        this._lastSentMsgId = 0;\n        /** @private */\n        this._paused = false;\n        /** @private */\n        this._resuming = false;\n        /** @private */\n        this._writeBufferSize = 0;\n        /** @private */\n        this._bytesRead = 0;\n        /** @private */\n        this._bytesWritten = 0;\n        /** @private */\n        this._connecting = false;\n        /** @private */\n        this._pending = true;\n        /** @private */\n        this._destroyed = false;\n        // TODO: Add readOnly and writeOnly states\n        /** @type {'opening' | 'open' | 'readOnly' | 'writeOnly'} @private */\n        this._readyState = 'open'; // Incorrect, but matches NodeJS behavior\n        /** @type {{ id: number; data: string; }[]} @private */\n        this._pausedDataEvents = [];\n        this.readableHighWaterMark = 16384;\n        this.writableHighWaterMark = 16384;\n        this.writableNeedDrain = false;\n        this.localAddress = undefined;\n        this.localPort = undefined;\n        this.remoteAddress = undefined;\n        this.remotePort = undefined;\n        this.remoteFamily = undefined;\n        this._registerEvents();\n    }\n\n    get readyState() {\n        return this._readyState;\n    }\n\n    get destroyed() {\n        return this._destroyed;\n    }\n\n    get pending() {\n        return this._pending;\n    }\n\n    get connecting() {\n        return this._connecting;\n    }\n\n    get bytesWritten() {\n        return this._bytesWritten;\n    }\n\n    get bytesRead() {\n        return this._bytesRead;\n    }\n\n    get timeout() {\n        return this._timeout;\n    }\n\n    /**\n     * @package\n     * @param {number} id\n     */\n    _setId(id) {\n        this._id = id;\n        this._registerEvents();\n    }\n\n    /**\n     * @package\n     * @param {NativeConnectionInfo} connectionInfo\n     */\n    _setConnected(connectionInfo) {\n        this._connecting = false;\n        this._readyState = 'open';\n        this._pending = false;\n        this.localAddress = connectionInfo.localAddress;\n        this.localPort = connectionInfo.localPort;\n        this.remoteAddress = connectionInfo.remoteAddress;\n        this.remoteFamily = connectionInfo.remoteFamily;\n        this.remotePort = connectionInfo.remotePort;\n    }\n\n    /**\n     * @param {ConnectionOptions} options\n     * @param {() => void} [callback]\n     */\n    connect(options, callback) {\n        if (this._id === undefined) this._setId(getNextId());\n\n        const customOptions = { ...options };\n        // Normalize args\n        customOptions.host = customOptions.host || 'localhost';\n        customOptions.port = Number(customOptions.port) || 0;\n        this.once('connect', () => {\n            if (callback) callback();\n        });\n        // Timeout\n        if (customOptions.timeout) this.setTimeout(customOptions.timeout);\n        else if (this._timeout) this._activateTimer();\n        // TLS Cert\n        if (customOptions.tlsCert) {\n            customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n        }\n        this._connecting = true;\n        this._readyState = 'opening';\n        Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n        return this;\n    }\n\n    /**\n     * Sets the socket to timeout after `timeout` milliseconds of inactivity on the socket. By default `TcpSocket` do not have a timeout.\n     *\n     * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed.\n     * The user must manually call `socket.end()` or `socket.destroy()` to end the connection.\n     *\n     * If `timeout` is 0, then the existing idle timeout is disabled.\n     *\n     * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n     *\n     * @param {number} timeout\n     * @param {() => void} [callback]\n     */\n    setTimeout(timeout, callback) {\n        if (timeout === 0) {\n            this._clearTimeout();\n        } else {\n            this._activateTimer(timeout);\n        }\n        if (callback) this.once('timeout', callback);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} [timeout]\n     */\n    _activateTimer(timeout) {\n        if (timeout !== undefined) this._timeoutMsecs = timeout;\n        this._clearTimeout();\n        this._timeout = setTimeout(() => {\n            this._clearTimeout();\n            this.emit('timeout');\n        }, this._timeoutMsecs);\n    }\n\n    /**\n     * @private\n     */\n    _clearTimeout() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n    }\n\n    /**\n     * Set the encoding for the socket as a Readable Stream. By default, no encoding is assigned and stream data will be returned as `Buffer` objects.\n     * Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as Buffer objects.\n     *\n     * For instance, calling `socket.setEncoding('utf8')` will cause the output data to be interpreted as UTF-8 data, and passed as strings.\n     * Calling `socket.setEncoding('hex')` will cause the data to be encoded in hexadecimal string format.\n     *\n     * @param {BufferEncoding} [encoding]\n     */\n    setEncoding(encoding) {\n        this._encoding = encoding;\n        return this;\n    }\n\n    /**\n     * Enable/disable the use of Nagle's algorithm. When a TCP connection is created, it will have Nagle's algorithm enabled.\n     *\n     * Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.\n     *\n     * Passing `true` for `noDelay` or not passing an argument will disable Nagle's algorithm for the socket. Passing false for noDelay will enable Nagle's algorithm.\n     *\n     * @param {boolean} noDelay Default: `true`\n     */\n    setNoDelay(noDelay = true) {\n        if (this._pending) {\n            this.once('connect', () => this.setNoDelay(noDelay));\n            return this;\n        }\n        Sockets.setNoDelay(this._id, noDelay);\n        return this;\n    }\n\n    /**\n     * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n     *\n     * `initialDelay` is ignored.\n     *\n     * @param {boolean} enable Default: `false`\n     * @param {number} initialDelay ***IGNORED**. Default: `0`\n     */\n    setKeepAlive(enable = false, initialDelay = 0) {\n        if (this._pending) {\n            this.once('connect', () => this.setKeepAlive(enable, initialDelay));\n            return this;\n        }\n\n        if (initialDelay !== 0) {\n            console.warn(\n                'react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored'\n            );\n        }\n\n        Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n        return this;\n    }\n\n    /**\n     * Returns the bound `address`, the address `family` name and `port` of the socket as reported\n     * by the operating system: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n     *\n     * @returns {AddressInfo | {}}\n     */\n    address() {\n        if (!this.localAddress) return {};\n        return { address: this.localAddress, family: this.remoteFamily, port: this.localPort };\n    }\n\n    /**\n     * Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.\n     *\n     * @param {string | Buffer | Uint8Array} [data]\n     * @param {BufferEncoding} [encoding]\n     */\n    end(data, encoding) {\n        if (data) {\n            this.write(data, encoding, () => {\n                Sockets.end(this._id);\n            });\n            return this;\n        }\n        if (this._pending || this._destroyed) return this;\n\n        this._clearTimeout();\n        Sockets.end(this._id);\n        return this;\n    }\n\n    /**\n     * Ensures that no more I/O activity happens on this socket. Destroys the stream and closes the connection.\n     */\n    destroy() {\n        if (this._pending || this._destroyed) return this;\n        this._destroyed = true;\n        this._clearTimeout();\n        Sockets.destroy(this._id);\n        return this;\n    }\n\n    /**\n     * Sends data on the socket. The second parameter specifies the encoding in the case of a string â€” it defaults to UTF8 encoding.\n     *\n     * Returns `true` if the entire data was flushed successfully to the kernel buffer. Returns `false` if all or part of the data\n     * was queued in user memory. `'drain'` will be emitted when the buffer is again free.\n     *\n     * The optional callback parameter will be executed when the data is finally written out, which may not be immediately.\n     *\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     * @param {(err?: Error) => void} [cb]\n     *\n     * @return {boolean}\n     */\n    write(buffer, encoding, cb) {\n        const self = this;\n        if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n\n        const generatedBuffer = this._generateSendBuffer(buffer, encoding);\n        this._writeBufferSize += generatedBuffer.byteLength;\n        const currentMsgId = this._msgId;\n        this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n        const msgEvtHandler = (/** @type {{id: number, msgId: number, err?: string}} */ evt) => {\n            const { msgId, err } = evt;\n            if (msgId === currentMsgId) {\n                this._msgEvtEmitter.removeListener('written', msgEvtHandler);\n                this._writeBufferSize -= generatedBuffer.byteLength;\n                this._lastRcvMsgId = msgId;\n                if (self._timeout) self._activateTimer();\n                if (this.writableNeedDrain && this._lastSentMsgId === msgId) {\n                    this.writableNeedDrain = false;\n                    this.emit('drain');\n                }\n                if (cb) {\n                    if (err) cb(new Error(err));\n                    else cb();\n                }\n            }\n        };\n        // Callback equivalent with better performance\n        this._msgEvtEmitter.on('written', msgEvtHandler, this);\n        const ok = this._writeBufferSize < this.writableHighWaterMark;\n        if (!ok) this.writableNeedDrain = true;\n        this._lastSentMsgId = currentMsgId;\n        this._bytesWritten += generatedBuffer.byteLength;\n        Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n        return ok;\n    }\n\n    /**\n     * Pauses the reading of data. That is, `'data'` events will not be emitted. Useful to throttle back an upload.\n     */\n    pause() {\n        if (this._paused) return;\n        this._paused = true;\n        Sockets.pause(this._id);\n        this.emit('pause');\n    }\n\n    /**\n     * Resumes reading after a call to `socket.pause()`.\n     */\n    resume() {\n        if (!this._paused) return;\n        this._paused = false;\n        this.emit('resume');\n        this._recoverDataEventsAfterPause();\n    }\n\n    ref() {\n        console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n    }\n\n    unref() {\n        console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n    }\n\n    /**\n     * @private\n     */\n    async _recoverDataEventsAfterPause() {\n        if (this._resuming) return;\n        this._resuming = true;\n        while (this._pausedDataEvents.length > 0) {\n            // Concat all buffered events for better performance\n            const buffArray = [];\n            let readBytes = 0;\n            let i = 0;\n            for (; i < this._pausedDataEvents.length; i++) {\n                const evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n                readBytes += evtData.byteLength;\n                if (readBytes <= this.readableHighWaterMark) {\n                    buffArray.push(evtData);\n                } else {\n                    const buffOffset = this.readableHighWaterMark - readBytes;\n                    buffArray.push(evtData.slice(0, buffOffset));\n                    this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n                    break;\n                }\n            }\n            // Generate new event with the concatenated events\n            const evt = {\n                id: this._pausedDataEvents[0].id,\n                data: Buffer.concat(buffArray).toString('base64'),\n            };\n            // Clean the old events\n            this._pausedDataEvents = this._pausedDataEvents.slice(i);\n            this._onDeviceDataEvt(evt);\n            if (this._paused) {\n                this._resuming = false;\n                return;\n            }\n        }\n        this._resuming = false;\n        Sockets.resume(this._id);\n    }\n\n    /**\n     * @private\n     */\n    _onDeviceDataEvt = (/** @type {{ id: number; data: string; }} */ evt) => {\n        if (evt.id !== this._id) return;\n        if (!this._paused) {\n            const bufferData = Buffer.from(evt.data, 'base64');\n            this._bytesRead += bufferData.byteLength;\n            const finalData = this._encoding ? bufferData.toString(this._encoding) : bufferData;\n            this.emit('data', finalData);\n        } else {\n            // If the socket is paused, save the data events for later\n            this._pausedDataEvents.push(evt);\n        }\n    };\n\n    /**\n     * @private\n     */\n    _registerEvents() {\n        this._unregisterEvents();\n        this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n        this._errorListener = this._eventEmitter.addListener('error', (evt) => {\n            if (evt.id !== this._id) return;\n            this.destroy();\n            this.emit('error', evt.error);\n        });\n        this._closeListener = this._eventEmitter.addListener('close', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setDisconnected();\n            this.emit('close', evt.error);\n        });\n        this._connectListener = this._eventEmitter.addListener('connect', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setConnected(evt.connection);\n            this.emit('connect');\n        });\n        this._writtenListener = this._eventEmitter.addListener('written', (evt) => {\n            if (evt.id !== this._id) return;\n            this._msgEvtEmitter.emit('written', evt);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _unregisterEvents() {\n        this._dataListener?.remove();\n        this._errorListener?.remove();\n        this._closeListener?.remove();\n        this._connectListener?.remove();\n        this._writtenListener?.remove();\n    }\n\n    /**\n     * @private\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     */\n    _generateSendBuffer(buffer, encoding) {\n        if (typeof buffer === 'string') {\n            return Buffer.from(buffer, encoding);\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n            return Buffer.from(buffer);\n        } else {\n            throw new TypeError(\n                `Invalid data, chunk must be a string or buffer, not ${typeof buffer}`\n            );\n        }\n    }\n\n    /**\n     * @private\n     */\n    _setDisconnected() {\n        this._unregisterEvents();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}