{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _eventemitter = _interopRequireDefault(require(\"eventemitter3\"));\n\nvar _Socket = _interopRequireDefault(require(\"./Socket\"));\n\nvar _Globals = require(\"./Globals\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Sockets = _reactNative.NativeModules.TcpSockets;\n\nvar Server = function (_EventEmitter) {\n  (0, _inherits2.default)(Server, _EventEmitter);\n\n  var _super = _createSuper(Server);\n\n  function Server(connectionCallback) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Server);\n    _this = _super.call(this);\n    _this._id = (0, _Globals.getNextId)();\n    _this._eventEmitter = _Globals.nativeEventEmitter;\n    _this._connections = new Set();\n    _this._localAddress = undefined;\n    _this._localPort = undefined;\n    _this._localFamily = undefined;\n    _this.listening = false;\n\n    _this._registerEvents();\n\n    if (connectionCallback) _this.on('connection', connectionCallback);\n\n    _this.on('close', _this._setDisconnected, (0, _assertThisInitialized2.default)(_this));\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(Server, [{\n    key: \"listen\",\n    value: function listen(options, callback) {\n      var _this2 = this;\n\n      if (this._localAddress !== undefined) throw new Error('ERR_SERVER_ALREADY_LISTEN');\n      var gotOptions = Object.assign({}, options);\n      gotOptions.host = gotOptions.host || '0.0.0.0';\n      this.once('listening', function () {\n        _this2.listening = true;\n        if (callback) callback();\n      });\n      Sockets.listen(this._id, gotOptions);\n      return this;\n    }\n  }, {\n    key: \"getConnections\",\n    value: function getConnections(callback) {\n      callback(null, this._connections.size);\n      return this;\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      if (!this._localAddress) {\n        callback == null ? void 0 : callback(new Error('ERR_SERVER_NOT_RUNNING'));\n        return this;\n      }\n\n      if (callback) this.once('close', callback);\n      this.listening = false;\n      Sockets.close(this._id);\n      return this;\n    }\n  }, {\n    key: \"address\",\n    value: function address() {\n      if (!this._localAddress) return null;\n      return {\n        address: this._localAddress,\n        port: this._localPort,\n        family: this._localFamily\n      };\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      console.warn('react-native-tcp-socket: Server.ref() method will have no effect.');\n      return this;\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      console.warn('react-native-tcp-socket: Server.unref() method will have no effect.');\n      return this;\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this3 = this;\n\n      this._errorListener = this._eventEmitter.addListener('listening', function (evt) {\n        if (evt.id !== _this3._id) return;\n        _this3._localAddress = evt.connection.localAddress;\n        _this3._localPort = evt.connection.localPort;\n        _this3._localFamily = evt.connection.localFamily;\n\n        _this3.emit('listening');\n      });\n      this._errorListener = this._eventEmitter.addListener('error', function (evt) {\n        if (evt.id !== _this3._id) return;\n\n        _this3.close();\n\n        _this3.emit('error', evt.error);\n      });\n      this._connectionsListener = this._eventEmitter.addListener('connection', function (evt) {\n        if (evt.id !== _this3._id) return;\n\n        var newSocket = _this3._buildSocket(evt.info);\n\n        newSocket.on('close', function () {\n          _this3._connections.delete(newSocket);\n\n          if (!_this3.listening && _this3._connections.size === 0) _this3.emit('close');\n        });\n\n        _this3._connections.add(newSocket);\n\n        _this3.emit('connection', newSocket);\n      });\n    }\n  }, {\n    key: \"_setDisconnected\",\n    value: function _setDisconnected() {\n      this._localAddress = undefined;\n      this._localPort = undefined;\n      this._localFamily = undefined;\n    }\n  }, {\n    key: \"_buildSocket\",\n    value: function _buildSocket(info) {\n      var newSocket = new _Socket.default();\n\n      newSocket._setId(info.id);\n\n      newSocket._setConnected(info.connection);\n\n      return newSocket;\n    }\n  }]);\n  return Server;\n}(_eventemitter.default);\n\nexports.default = Server;","map":{"version":3,"names":["Sockets","NativeModules","TcpSockets","Server","connectionCallback","_id","getNextId","_eventEmitter","nativeEventEmitter","_connections","Set","_localAddress","undefined","_localPort","_localFamily","listening","_registerEvents","on","_setDisconnected","options","callback","Error","gotOptions","host","once","listen","size","close","address","port","family","console","warn","_errorListener","addListener","evt","id","connection","localAddress","localPort","localFamily","emit","error","_connectionsListener","newSocket","_buildSocket","info","delete","add","Socket","_setId","_setConnected","EventEmitter"],"sources":["/home/ywha/WEB_FLUID/react_proxy/node_modules/react-native-tcp-socket/src/Server.js"],"sourcesContent":["'use strict';\n\nimport { NativeModules } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nconst Sockets = NativeModules.TcpSockets;\nimport Socket from './Socket';\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {object} ServerEvents\n * @property {() => void} close\n * @property {(socket: Socket) => void} connection\n * @property {() => void} listening\n * @property {(err: Error) => void} error\n *\n * @extends {EventEmitter<ServerEvents, any>}\n */\nexport default class Server extends EventEmitter {\n    /**\n     * @param {(socket: Socket) => void} [connectionCallback] Automatically set as a listener for the `'connection'` event.\n     */\n    constructor(connectionCallback) {\n        super();\n        /** @private */\n        this._id = getNextId();\n        /** @private */\n        this._eventEmitter = nativeEventEmitter;\n        /** @private @type {Set<Socket>} */\n        this._connections = new Set();\n        /** @private */\n        this._localAddress = undefined;\n        /** @private */\n        this._localPort = undefined;\n        /** @private */\n        this._localFamily = undefined;\n        this.listening = false;\n        this._registerEvents();\n        if (connectionCallback) this.on('connection', connectionCallback);\n        this.on('close', this._setDisconnected, this);\n    }\n\n    /**\n     * Start a server listening for connections.\n     *\n     * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted.\n     * The last parameter `callback` will be added as a listener for the `'listening'` event.\n     *\n     * The `server.listen()` method can be called again if and only if there was an error during the first\n     * `server.listen()` call or `server.close()` has been called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN`\n     * error will be thrown.\n     *\n     * @param {{ port: number; host: string; reuseAddress?: boolean}} options\n     * @param {() => void} [callback]\n     * @returns {Server}\n     */\n    listen(options, callback) {\n        if (this._localAddress !== undefined) throw new Error('ERR_SERVER_ALREADY_LISTEN');\n        const gotOptions = { ...options };\n        gotOptions.host = gotOptions.host || '0.0.0.0';\n        this.once('listening', () => {\n            this.listening = true;\n            if (callback) callback();\n        });\n        Sockets.listen(this._id, gotOptions);\n        return this;\n    }\n\n    /**\n     * Asynchronously get the number of concurrent connections on the server.\n     *\n     * Callback should take two arguments `err` and `count`.\n     *\n     * @param {(err: Error | null, count: number) => void} callback\n     * @returns {Server}\n     */\n    getConnections(callback) {\n        callback(null, this._connections.size);\n        return this;\n    }\n\n    /**\n     * Stops the server from accepting new connections and keeps existing connections.\n     * This function is asynchronous, the server is finally closed when all connections are ended and the server emits a `'close'` event.\n     * The optional callback will be called once the `'close'` event occurs. Unlike that event, it will be called with an `Error` as its\n     * only argument if the server was not open when it was closed.\n     *\n     * @param {(err?: Error) => void} [callback] Called when the server is closed.\n     * @returns {Server}\n     */\n    close(callback) {\n        if (!this._localAddress) {\n            callback?.(new Error('ERR_SERVER_NOT_RUNNING'));\n            return this;\n        }\n        if (callback) this.once('close', callback);\n        this.listening = false;\n        Sockets.close(this._id);\n        return this;\n    }\n\n    /**\n     * Returns the bound `address`, the address `family` name, and `port` of the server as reported by the operating system if listening\n     * on an IP socket (useful to find which port was assigned when getting an OS-assigned address):\n     * `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n     *\n     * @returns {import('./Socket').AddressInfo | null}\n     */\n    address() {\n        if (!this._localAddress) return null;\n        return { address: this._localAddress, port: this._localPort, family: this._localFamily };\n    }\n\n    ref() {\n        console.warn('react-native-tcp-socket: Server.ref() method will have no effect.');\n        return this;\n    }\n\n    unref() {\n        console.warn('react-native-tcp-socket: Server.unref() method will have no effect.');\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    _registerEvents() {\n        this._errorListener = this._eventEmitter.addListener('listening', (evt) => {\n            if (evt.id !== this._id) return;\n            this._localAddress = evt.connection.localAddress;\n            this._localPort = evt.connection.localPort;\n            this._localFamily = evt.connection.localFamily;\n            this.emit('listening');\n        });\n        this._errorListener = this._eventEmitter.addListener('error', (evt) => {\n            if (evt.id !== this._id) return;\n            this.close();\n            this.emit('error', evt.error);\n        });\n        this._connectionsListener = this._eventEmitter.addListener('connection', (evt) => {\n            if (evt.id !== this._id) return;\n            const newSocket = this._buildSocket(evt.info);\n            // Emit 'close' when all connection closed\n            newSocket.on('close', () => {\n                this._connections.delete(newSocket);\n                if (!this.listening && this._connections.size === 0) this.emit('close');\n            });\n            this._connections.add(newSocket);\n            this.emit('connection', newSocket);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _setDisconnected() {\n        this._localAddress = undefined;\n        this._localPort = undefined;\n        this._localFamily = undefined;\n    }\n\n    /**\n     * @private\n     * @param {{ id: number; connection: import('./Socket').NativeConnectionInfo; }} info\n     * @returns {Socket}\n     */\n    _buildSocket(info) {\n        const newSocket = new Socket();\n        newSocket._setId(info.id);\n        newSocket._setConnected(info.connection);\n        return newSocket;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}