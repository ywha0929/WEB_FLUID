{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useAnimatedProps;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _AnimatedProps = _interopRequireDefault(require(\"./nodes/AnimatedProps\"));\n\nvar _AnimatedEvent = require(\"./AnimatedEvent\");\n\nvar _useRefEffect = _interopRequireDefault(require(\"../Utilities/useRefEffect\"));\n\nvar _NativeAnimatedHelper = _interopRequireDefault(require(\"./NativeAnimatedHelper\"));\n\nvar _react = require(\"react\");\n\nvar _useLayoutEffect = _interopRequireDefault(require(\"../../../modules/useLayoutEffect\"));\n\nfunction useAnimatedProps(props) {\n  var _useReducer = (0, _react.useReducer)(function (count) {\n    return count + 1;\n  }, 0),\n      scheduleUpdate = _useReducer[1];\n\n  var onUpdateRef = (0, _react.useRef)(null);\n  var node = (0, _react.useMemo)(function () {\n    return new _AnimatedProps.default(props, function () {\n      return onUpdateRef.current == null ? void 0 : onUpdateRef.current();\n    });\n  }, [props]);\n  useAnimatedPropsLifecycle(node);\n  var refEffect = (0, _react.useCallback)(function (instance) {\n    node.setNativeView(instance);\n\n    onUpdateRef.current = function () {\n      scheduleUpdate();\n    };\n\n    var target = getEventTarget(instance);\n    var events = [];\n\n    for (var propName in props) {\n      var propValue = props[propName];\n\n      if (propValue instanceof _AnimatedEvent.AnimatedEvent && propValue.__isNative) {\n        propValue.__attach(target, propName);\n\n        events.push([propName, propValue]);\n      }\n    }\n\n    return function () {\n      onUpdateRef.current = null;\n\n      for (var _i = 0, _events = events; _i < _events.length; _i++) {\n        var _events$_i = _events[_i],\n            _propName = _events$_i[0],\n            _propValue = _events$_i[1];\n\n        _propValue.__detach(target, _propName);\n      }\n    };\n  }, [props, node]);\n  var callbackRef = (0, _useRefEffect.default)(refEffect);\n  return [reduceAnimatedProps(node), callbackRef];\n}\n\nfunction reduceAnimatedProps(node) {\n  return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, node.__getValue()), {}, {\n    collapsable: false\n  });\n}\n\nfunction useAnimatedPropsLifecycle(node) {\n  var prevNodeRef = (0, _react.useRef)(null);\n  var isUnmountingRef = (0, _react.useRef)(false);\n  (0, _react.useEffect)(function () {\n    _NativeAnimatedHelper.default.API.flushQueue();\n  });\n  (0, _useLayoutEffect.default)(function () {\n    isUnmountingRef.current = false;\n    return function () {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  (0, _useLayoutEffect.default)(function () {\n    node.__attach();\n\n    if (prevNodeRef.current != null) {\n      var prevNode = prevNodeRef.current;\n\n      prevNode.__restoreDefaultValues();\n\n      prevNode.__detach();\n\n      prevNodeRef.current = null;\n    }\n\n    return function () {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\n\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ? instance.getScrollableNode() : instance;\n}\n\nfunction isFabricInstance(instance) {\n  var _instance$getScrollRe;\n\n  return hasFabricHandle(instance) || hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());\n}\n\nfunction hasFabricHandle(instance) {\n  var _instance$_internalIn, _instance$_internalIn2;\n\n  return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;\n}","map":{"version":3,"names":["useAnimatedProps","props","_useReducer","useReducer","count","scheduleUpdate","onUpdateRef","useRef","node","useMemo","AnimatedProps","current","useAnimatedPropsLifecycle","refEffect","useCallback","instance","setNativeView","target","getEventTarget","events","propName","propValue","AnimatedEvent","__isNative","__attach","push","_i","_events","length","_events$_i","_propName","_propValue","__detach","callbackRef","useRefEffect","reduceAnimatedProps","_objectSpread","__getValue","collapsable","prevNodeRef","isUnmountingRef","useEffect","NativeAnimatedHelper","API","flushQueue","useLayoutEffect","prevNode","__restoreDefaultValues","getScrollableNode","isFabricInstance","_instance$getScrollRe","hasFabricHandle","getNativeScrollRef","getScrollResponder","_instance$_internalIn","_instance$_internalIn2","stateNode","canonical"],"sources":["/home/ywha/WEB_FLUID/react_proxy/node_modules/react-native-web/dist/vendor/react-native/Animated/useAnimatedProps.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AnimatedProps from './nodes/AnimatedProps';\nimport { AnimatedEvent } from './AnimatedEvent';\nimport useRefEffect from '../Utilities/useRefEffect';\nimport NativeAnimatedHelper from './NativeAnimatedHelper';\nimport { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';\nimport useLayoutEffect from '../../../modules/useLayoutEffect';\nexport default function useAnimatedProps(props) {\n  var _useReducer = useReducer(count => count + 1, 0),\n    scheduleUpdate = _useReducer[1];\n  var onUpdateRef = useRef(null);\n\n  // TODO: Only invalidate `node` if animated props or `style` change. In the\n  // previous implementation, we permitted `style` to override props with the\n  // same name property name as styles, so we can probably continue doing that.\n  // The ordering of other props *should* not matter.\n  var node = useMemo(() => new AnimatedProps(props, () => onUpdateRef.current == null ? void 0 : onUpdateRef.current()), [props]);\n  useAnimatedPropsLifecycle(node);\n\n  // TODO: This \"effect\" does three things:\n  //\n  //   1) Call `setNativeView`.\n  //   2) Update `onUpdateRef`.\n  //   3) Update listeners for `AnimatedEvent` props.\n  //\n  // Ideally, each of these would be separat \"effects\" so that they are not\n  // unnecessarily re-run when irrelevant dependencies change. For example, we\n  // should be able to hoist all `AnimatedEvent` props and only do #3 if either\n  // the `AnimatedEvent` props change or `instance` changes.\n  //\n  // But there is no way to transparently compose three separate callback refs,\n  // so we just combine them all into one for now.\n  var refEffect = useCallback(instance => {\n    // NOTE: This may be called more often than necessary (e.g. when `props`\n    // changes), but `setNativeView` already optimizes for that.\n    node.setNativeView(instance);\n\n    // NOTE: This callback is only used by the JavaScript animation driver.\n    onUpdateRef.current = () => {\n      // Schedule an update for this component to update `reducedProps`,\n      // but do not compute it immediately. If a parent also updated, we\n      // need to merge those new props in before updating.\n      scheduleUpdate();\n    };\n    var target = getEventTarget(instance);\n    var events = [];\n    for (var propName in props) {\n      var propValue = props[propName];\n      if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n        propValue.__attach(target, propName);\n        events.push([propName, propValue]);\n      }\n    }\n    return () => {\n      onUpdateRef.current = null;\n      for (var _i = 0, _events = events; _i < _events.length; _i++) {\n        var _events$_i = _events[_i],\n          _propName = _events$_i[0],\n          _propValue = _events$_i[1];\n        _propValue.__detach(target, _propName);\n      }\n    };\n  }, [props, node]);\n  var callbackRef = useRefEffect(refEffect);\n  return [reduceAnimatedProps(node), callbackRef];\n}\nfunction reduceAnimatedProps(node) {\n  // Force `collapsable` to be false so that the native view is not flattened.\n  // Flattened views cannot be accurately referenced by the native driver.\n  return _objectSpread(_objectSpread({}, node.__getValue()), {}, {\n    collapsable: false\n  });\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, this is more complicated because `AnimatedProps`\n * uses reference counting to determine when to recursively detach its children\n * nodes. So in order to optimize this, we avoid detaching until the next attach\n * unless we are unmounting.\n */\nfunction useAnimatedPropsLifecycle(node) {\n  var prevNodeRef = useRef(null);\n  var isUnmountingRef = useRef(false);\n  useEffect(() => {\n    // It is ok for multiple components to call `flushQueue` because it noops\n    // if the queue is empty. When multiple animated components are mounted at\n    // the same time. Only first component flushes the queue and the others will noop.\n    NativeAnimatedHelper.API.flushQueue();\n  });\n  useLayoutEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  useLayoutEffect(() => {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      var prevNode = prevNodeRef.current;\n      // TODO: Stop restoring default values (unless `reset` is called).\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ?\n  // $FlowFixMe[incompatible-use] - Legacy instance assumptions.\n  instance.getScrollableNode() : instance;\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction isFabricInstance(instance) {\n  var _instance$getScrollRe;\n  return hasFabricHandle(instance) ||\n  // Some components have a setNativeProps function but aren't a host component\n  // such as lists like FlatList and SectionList. These should also use\n  // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying\n  // host component. This crazy hack is essentially special casing those lists and\n  // ScrollView itself to use forceUpdate in Fabric.\n  // If these components end up using forwardRef then these hacks can go away\n  // as instance would actually be the underlying host component and the above check\n  // would be sufficient.\n  hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction hasFabricHandle(instance) {\n  var _instance$_internalIn, _instance$_internalIn2;\n  // eslint-disable-next-line dot-notation\n  return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}